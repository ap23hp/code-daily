# Day1
#### we created a simple render function which takes react element and a container. React element is normal javascript object with type(which HTML Tag to create), props(contains HTML attributes) and children(text inside element)
#### React elements are just JavaScript objects.
#### Rendering means converting those objects into real DOM nodes.
#### JSX and React APIs are abstractions over normal DOM operations.

#### Instead of writing React.createElement, we use an HTML-like syntax to create React elements - JSX coz it is easier to read.
#### React elements can form a tree structure, just like HTML elements This happens when we set the “children” parameter of a React element to another React element. In practice, we often wind up with pretty significant tree structures in our React code. Hence we use JSX coz HTML-like syntax is easier for our brains to process

#### If we try to run this JSX code in the browser, we'll get an error. JavaScript engines don't understand JSX, they only understand JavaScript. And so we need to "compile" our code into plain JS.This is most commonly done as part of a build step, using a tool like BabelThe JSX we write gets converted into React.createElement. By the time our code is running in the user's browser, all of the JSX has been zapped out, and we're left with a JS file full of nested React.createElement calls.

#### statements is action and expression produces a value. We can create expression slots with curly brackets ({}). Anything placed in-between curly brackets will be treated as pure JavaScript, instead of a string.
#### use the multi-line comment syntax (/* */)

#### htmlFor, className, JSX is case-sensitive,Our tags must all be lowercase. In JSX, our attributes need to be “camelCase.   data-test-id and aria-label are not camel case-exceptions.We can introduce white space in react using   {' '}
#### We write React using JSX and imports because tools like Vite bundle and compile the code into browser-understandable JavaScript.

####  the browser cannot execute ES module imports without type="module", so React never runs.
#### When we pass something between the open and close tags, React will automatically supply that value to us under children.It appears that React chooses to prioritize the children passed in-between the open/close tags

#### The `<dl>` HTML tag is fairly obscure, but a super worthwhile tag!It stands for “Description List”, and it's intended to be used to display key/value pairs. For example, many e-commerce platforms will display product details in this format

#### React components are just JavaScript functions, and a function can return only one value. JSX may look like HTML, but it compiles into a single function call that creates one JavaScript object (a React element). When you try to return two or three React elements without a wrapper, you’re actually trying to return multiple JavaScript objects at once, which JavaScript simply doesn’t allow.One option is to wrap both React elements in a div but not recommended  It pollutes the DOM with unnecessary elements. And it can even lead to accessibility and layout issues.Hence we have React Fragments.Fragments allow us to respect the rules of JavaScript without polluting the HTML.A fragment is a special React component that does not produce a DOM node. 
#### There is one thing React does provide for us: we can pass an array, and React will unpack and render each item for us. For example, we can render {['hello', 'world']} and we'll see the content “helloworld” included in the DOM.React renders arrays by iterating over them and rendering each item as a sibling node.

#### When we give React an array of elements, we also need to help React out by uniquely identifying each element.so we have keys.why keys are necessary- React does not know specifically what happens when we change data All React sees is the before/after. Think of React like a person comparing two photos of the same room—one taken before a change and one after. React doesn’t see what action you took (added an item, removed one, or reordered them); it only sees the old snapshot and the new snapshot. Now imagine all the items in the room look similar—React won’t know which chair is the same chair as before unless each one has a name tag. That’s exactly what keys are. A key gives each item a permanent identity, so React can recognize, “This item is the same as before, just moved,” or “This one is new,” or “This one was removed.” Without keys, React has to guess, which can cause unnecessary DOM updates, poor performance, or weird bugs like input fields losing focus. Keys act like a clear route map for React, helping it update only what actually changed and keep everything stable and efficient.

#### In React, some words are special and kept aside for React’s own use, and key is one of them. Think of it like a luggage tag at the airport—it’s used by the airport staff to track your bag, not by you once you land. In the same way, when you add a key to a React element, React reads it only for its internal tracking, to understand which item is which in a list. That key is not passed to the component as a normal prop, so the component itself can’t access it using props.key. It exists purely to help React manage updates efficiently behind the scenes, and once React finishes its job, the key is essentially invisible to your component. Keys are a property of the element itself, not something that needs to be passed along to the component!

#### the key must be placed on the outermost element that you return from the .map() function, not on any nested child inside it. When React processes a list created with .map(), it looks only at the top-level elements of that list to tell them apart from each other. If the key is placed deeper inside—on a child element—React can’t see it when comparing the list items, so it becomes useless for React’s tracking. By putting the key on the very first (outer) element returned in each iteration, you are clearly telling React, “This whole block is one unique item,” which allows React to correctly match items between renders and update the DOM efficiently without confusion or bugs.

#### When using fragments, it's sometimes required to switch to the long-form React.Fragment, so that we can apply the key. Keys only have to be unique within their array.

#### With the curly brackets, we can add JavaScript expressions within our JSX. Unfortunately, though, we can't add JavaScript statements:JSX is just a prettier way of writing React.createElement. When JSX is compiled, React doesn’t “run HTML”; it calls a function that creates plain JavaScript objects describing the UI. That function looks like this:React.createElement(type, props, children) Now here’s the key point: when you call a function, every argument must be a value. You can pass numbers, strings, objects, expressions—anything that evaluates to a value. But you cannot put an if statement inside a function call, because if is a statement, not a value. Statements control program flow, but they don’t produce something that can be passed as an argument.we can still use an if statement! But we have to pull it up so that it's not in the middle of a React.createElement call.

#### react ignores undefines completely.

#### The && operator doesn't return true or false. It returns either the left-hand side or the right-hand side. So, when our list is empty, this expression evaluates to 0.React will render any number you give it, even zero!React will ignore most falsy values like false or null, but it won't ignore the number zero.so ### To avoid having random 0 characters in our application, make sure that the left-hand side of && always evaluates to a boolean value, either true or false.The “greater than” operator (>) will always produce a boolean value, either true or false.DOM nodes memory consume karte hain sirf exist karne se, chahe wo visible hon ya nahi, isliye large apps me conditional rendering use karke extra nodes DOM se hata dena memory ke liye better hota hai.Lekin DOM node create ya destroy karna slow process hota hai, especially jab user baar-baar content show/hide karta ho.Isliye frequent toggles (jaise accordion) me CSS display use karna fast hota hai, aur rarely used content ke liye conditional rendering better hoti hai.

#### A hook is a special type of function in React that allows a function component to access and use React’s built-in features, which are otherwise handled internally by React. When we say hooks “hook into React internals,” it means they connect our component to React’s internal systems such as state management, lifecycle behavior, and context. For example, hooks like useState let a function component store and update state, and useEffect lets it run side effects at specific points in the component’s lifecycle. Hooks make it possible to use these powerful React features without writing class components, resulting in cleaner, simpler, and more reusable code.

#### The useState hook returns an array containing two items:The current value of the state variable. and a function we can use to update the state variable. 
#### React state variables are given an initial value. We can supply a function also- called initializer function. React will call this functionon the very first render to calculate the initial value. t can occasionally be useful if we need to do an expensive operation to calculate the initial value. For example, reading from Local Storage:it's a way for us to save values on the user's device, so that it persists even after the browser tab is closed, and can be accessed on their next visit.The benefit here is that we're only doing the expensive work (reading from Local Storage) once, on the initial render, rather than doing it on every single render.

##### function Counter() {const [count, setCount] = React.useState(() => { return window.localStorage.getItem('saved-count'); });} we do it by wrapping it inside arrow function rather than directly putting it so that On the very first render, React will call this function to calculate the initial value. On subsequent renders, however, React ignores the function. The initial value has already been calculated, and so there's no reason to call the function again.

####  we update a state variable by calling the setter function (setCount), the UI gets updated. But how does this work, exactly?-In simple, everyday terms, you can think of each React render as taking a photo (or snapshot) of the UI at a particular moment. Every time something changes—like state or props—React creates a new snapshot that describes what the screen should look like now. For example, before clicking a button, the snapshot shows Value: 0, and after the click, a new snapshot shows Value: 1. React then compares the old photo with the new one, much like those “spot the difference” games where you look for what changed between two images. This comparison process is called reconciliation. Using smart and efficient algorithms, React figures out exactly what’s different between the two snapshots. Once it knows the differences, React carefully updates only those specific parts of the real webpage (the DOM) that need to change—nothing more. In this case, it simply updates the button text to Value: 1. This snapshot → compare → update cycle is the core flow that React follows to keep the UI fast and in sync with the data.Hence the name of the library-coz it reacts to changes.

#### Mount is the very first time a component appears on the screen. Since React has nothing to compare it with yet, it simply runs the component, creates all the required DOM elements from scratch, and places them on the page.Later, a trigger happens—usually a state update like calling setCount. This does not directly change the screen; it only tells React that some data has changed. Because of this change, React moves to the render phase, where it runs the component function again and creates a fresh description (snapshot) of what the UI should look like now. React then compares this new snapshot with the previous one to find what has changed. Finally, in the commit phase, React applies only those necessary changes to the real DOM—such as updating text, adding new elements, or removing old ones. After committing these updates, React becomes idle again and waits for the next state change to repeat the cycle.

#### Trigger → Render (new snapshot) → Reconcile (compare) → Commit (update DOM) → Idle
#### React state updates are asynchronous because when we call a state setter, React does not update the state immediately. Instead, React notes down the change, schedules an update, and then creates a new snapshot of the UI. It compares this new snapshot with the previous one, figures out what has changed, and only updates those parts of the DOM. After that, the browser repaints the screen. Because this whole process happens later, if we log the state immediately after calling the setter, we often see the previous state, not the updated one.
#### When multiple state updates happen inside the same event (like clicking a “Log Out” button), React does not update the UI immediately for each one. Instead, it notes down all the changes, batches them together, and performs one single re-render after the event handler finishes. This is important for both performance and correctness. If state updates were synchronous, React would re-render after every setState call, doing unnecessary extra work and potentially showing broken UI—for example, updating user to null before the confirmation message is ready, resulting in empty or inconsistent content. By keeping state updates asynchronous and batched, React ensures the UI updates once, efficiently, and in a consistent final state, even though it can be confusing at first when logging state values immediately after setting them.
#### A re-render creates and compares UI snapshots inside React, but the browser only repaints when React actually changes the real DOM.Not all re-renders require re-paints! If nothing has changed between snapshots, React won't edit any DOM nodes, and nothing will be re-painted.
#### so first step is to create a form component that will render form- inputs. Next we create states using useState, then inside the state we use object to give values to out multiple inputs. otherwise we would have to make a lot of states in case of multiple inputs. Then we bind out form input by using value attribute and in this value attribute we put state for that perticular input from out state object. Then on the inputs we use name attribute to give them the same name as our states. Till here half binding is done. Now on chnage of input user should be able to type and we should be able to see thta. so we do that by writing onChnage on the input. In select type of input always remeber we put onChnage , value and name on the select . Now onChnage will do these things--> first it will be getting an event object from the browser the moment anyone tries to type in input. next we will target the input using e.target.value and e.target.name. This will give us the value and the input with which the value is attached. Next onChnage of input we need to change the value. so setState function will be called and we will pass updated object of state in it using spread operator in which we will get old objecta dn we will pass whatever new has chnaged. This was we do not muttate the state object directly

####  React 19 introduced Actions as a new way to handle form submissions. In the classic method, we use controlled inputs, where each form field is connected to React state using useState and updated with onChange handlers. This allows React to know the value of each input in real time, making it easy to show live previews, validations, or instant feedback while the user is typing. When the form is submitted, an onSubmit function handles sending the collected state data to the server and managing loading or error states. Actions are a new way to handle form submission in React 19 without using useState for every input.With Actions:React itself collects all input values when the form is submitted , You work with the data only at submit time Instead of tracking input values while the user is typing, React waits until the form is submitted and then automatically collects all the input data for us. In the code, useActionState gives us three things: the current result or error, a function called submitAction that runs when the form is submitted, and a boolean isPending that tells us whether the submission is still in progress. Instead of using onSubmit, we pass submitAction to the form using action={submitAction}, which means “run this action when the form is submitted.” The input fields are uncontrolled, meaning they don’t use value or onChange; they only need a name attribute so React can read their values from formData at submit time. This makes forms less verbose and easier to write, especially large ones, but because the data is only available on submit, Actions are not suitable for cases where we need real-time access to input values, such as live search or instant previews.

#### Forms reload the page by default because of legacy browser behavior. event.preventDefault(). It stops the browser from executing a full page reload.

#### All form controls in React follow the same basic pattern: the current value of the input is locked using either the `value` attribute (for text inputs, textareas, selects, sliders, color pickers, etc.) or the `checked` attribute (for checkboxes and radio buttons), and any change made by the user is handled through the `onChange` event, which updates React state. For text inputs and textareas, controlled components bind state to `value`,
#### while uncontrolled components can use `defaultValue` to set an initial value. It is important to always initialize state with a valid value (usually an empty string for text inputs) to avoid bugs caused by switching from uncontrolled to controlled inputs. 

#### Radio buttons are controlled using a boolean `checked` value and typically share the same `name` attribute so only one option can be selected, while checkboxes also rely on `checked`, storing either a single boolean for one checkbox or an object-like structure for multiple checkboxes. 
#### Select dropdowns work like text inputs, using `value` and `onChange`, and the initial state must exactly match one of the option values to prevent unexpected behavior. 
#### Specialty inputs such as range sliders, date pickers, and color pickers follow the same controlled pattern as text inputs, with the important caveat that input values from the DOM are always strings, even for numeric inputs, so conversion may be required. 
#### Finally, because forms reload the page by default, modern React applications always call `event.preventDefault()` on submit to stop the browser’s default behavior and allow React to handle updates smoothly without a full page refresh.

#### React uses a synthetic event system, which means the events we receive in React are special objects created by React, not the browser’s native JavaScript events. React does this to provide consistent behavior across different browsers, avoiding edge-case differences in how native events work. These synthetic events also improve the developer experience by offering a uniform and predictable API. Earlier versions of React used this system for performance optimizations like event pooling, but this was removed in React 17, so features like event.persist() are no longer needed. If required, the original browser event can still be accessed using event.nativeEvent.Different browsers do not implement events in exactly the same way.The event object, its properties, and even when an event fires can vary slightly between Chrome, Firefox, Safari, Edge, etc.React’s synthetic event system normalizes these differences, so you write one kind of code and it works the same everywhere.

#### Props allow us to customize the behaviour of a given component, so that the exact same component can do different things in different scenarios.Props are the inputs to our components, like arguments passed to a function .React state is used to track data that changes over time By default, state is only made available to the current component. so props: they're the tunnels that allow data to flow through our application.
#### Never mutate React state, even if it appears to work, because React relies on the assumption that state values are treated as immutable.he correct approach is always to create a new copy of the state first, apply changes to that copy, and then pass the new value to the state setter. While some developers worry that creating new arrays or objects on every update might be inefficient, in practice this cost is negligible—modern JavaScript engines can clone arrays extremely quickly, even on low-end hardware, and the time taken is far below what humans can perceive. As a result, immutability is not only safer and more predictable, but also fast enough for real-world front-end applications, making it the correct and recommended way to manage React state.

#### Setting a React list key to Math.random() may remove the warning, but it introduces a serious performance problem because the key changes on every render. Since Math.random() generates a new value each time, React thinks that every item in the list is completely new whenever the component re-renders. As a result, even if only one new item is added, React deletes all existing DOM elements and recreates them from scratch instead of updating only what actually changed. Because DOM operations are relatively expensive, this unnecessary destruction and recreation can significantly hurt performance. The correct idea is not to avoid randomness altogether, but to ensure that the key remains stable across renders. This can be achieved by generating the random ID once—at the moment the item is created, such as inside a click handler—and storing it with the item’s data. In this way, React can reliably identify which items are unchanged and update only the new ones. Besides Math.random(), safer alternatives like crypto.randomUUID() can also be used to generate unique, stable identifiers.

#### In simple terms, keys help React recognize which item is which in a list. If we use the array index or something like the list length as a key, React can get confused when items are added, removed, or moved, and it may update or delete the wrong elements on the screen. This can cause weird bugs and extra work for the browser. While using indexes might seem fine when the list never changes, it’s easy to be wrong about that. That’s why it’s safer to give each item its own unique and fixed ID so React always knows exactly what has changed.

#### In React, data (state) can only move in one direction, like water flowing downhill — from a parent component to its child components using props. Two sibling components cannot talk to each other directly or share data on their own. So if both siblings need the same information, the only solution is to keep that information in their common parent. The parent then shares the state with both children and can also pass the function that updates the state, so children are allowed to change it.Here’s how it works in real life: when a user types something into a textbox, a change event happens. That change calls a state-update function which actually belongs to the parent component. Because the parent owns the state, updating it causes the parent to re-render, and when the parent re-renders, all its children re-render too. One child (the form) gets the updated value and shows it in the input, while the other child (the results) also receives the same updated value and displays it wherever needed.Now, you might wonder — why not just put all state at the very top of the app? The reason is that doing this in larger apps makes everything slow and messy. Too much state at the top causes unnecessary re-renders and makes the code hard to understand and maintain. That’s why in React, we only “lift state up” when it’s actually shared, not everywhere.

#### parent passes down a function so that the child can update the parent's state
#### Think of a React component like a real object, not just some JSX on the screen. When a component appears on the page for the first time, React “mounts” it, which means two things happen: React turns the JSX into real DOM elements, and at the same time it creates a component instance—a little invisible box that belongs only to that component. This box is where React stores things like state. When we use useState, we’re not storing data in the JSX or in some global place; we’re simply reading from and writing to this component’s own instance box. If the component disappears from the screen because of conditional rendering, React “unmounts” it, which destroys that box and all the state inside it is lost. And because every component on the screen gets its own instance box, React can show multiple copies of the same component, with each copy remembering its own state independently.