# Day1
## we created a simple render function which takes react element and a container. React element is normal javascript object with type(which HTML Tag to create), props(contains HTML attributes) and children(text inside element)
## React elements are just JavaScript objects.
## Rendering means converting those objects into real DOM nodes.
## JSX and React APIs are abstractions over normal DOM operations.

## Instead of writing React.createElement, we use an HTML-like syntax to create React elements - JSX coz it is easier to read.
## React elements can form a tree structure, just like HTML elements This happens when we set the “children” parameter of a React element to another React element. In practice, we often wind up with pretty significant tree structures in our React code. Hence we use JSX coz HTML-like syntax is easier for our brains to process

## If we try to run this JSX code in the browser, we'll get an error. JavaScript engines don't understand JSX, they only understand JavaScript. And so we need to "compile" our code into plain JS.This is most commonly done as part of a build step, using a tool like BabelThe JSX we write gets converted into React.createElement. By the time our code is running in the user's browser, all of the JSX has been zapped out, and we're left with a JS file full of nested React.createElement calls.

## statements is action and expression produces a value. We can create expression slots with curly brackets ({}). Anything placed in-between curly brackets will be treated as pure JavaScript, instead of a string.
## use the multi-line comment syntax (/* */)

## htmlFor, className, JSX is case-sensitive,Our tags must all be lowercase. In JSX, our attributes need to be “camelCase.   data-test-id and aria-label are not camel case-exceptions.We can introduce white space in react using   {' '}
## We write React using JSX and imports because tools like Vite bundle and compile the code into browser-understandable JavaScript.

##  the browser cannot execute ES module imports without type="module", so React never runs.
## When we pass something between the open and close tags, React will automatically supply that value to us under children.It appears that React chooses to prioritize the children passed in-between the open/close tags

### The <dl> HTML tag is fairly obscure, but a super worthwhile tag!It stands for “Description List”, and it's intended to be used to display key/value pairs. For example, many e-commerce platforms will display product details in this format

#### React components are just JavaScript functions, and a function can return only one value. JSX may look like HTML, but it compiles into a single function call that creates one JavaScript object (a React element). When you try to return two or three React elements without a wrapper, you’re actually trying to return multiple JavaScript objects at once, which JavaScript simply doesn’t allow.One option is to wrap both React elements in a div but not recommended  It pollutes the DOM with unnecessary elements. And it can even lead to accessibility and layout issues.Hence we have React Fragments.Fragments allow us to respect the rules of JavaScript without polluting the HTML.A fragment is a special React component that does not produce a DOM node. 
#### There is one thing React does provide for us: we can pass an array, and React will unpack and render each item for us. For example, we can render {['hello', 'world']} and we'll see the content “helloworld” included in the DOM.React renders arrays by iterating over them and rendering each item as a sibling node.

#### When we give React an array of elements, we also need to help React out by uniquely identifying each element.so we have keys.why keys are necessary- React does not know specifically what happens when we change data All React sees is the before/after. Think of React like a person comparing two photos of the same room—one taken before a change and one after. React doesn’t see what action you took (added an item, removed one, or reordered them); it only sees the old snapshot and the new snapshot. Now imagine all the items in the room look similar—React won’t know which chair is the same chair as before unless each one has a name tag. That’s exactly what keys are. A key gives each item a permanent identity, so React can recognize, “This item is the same as before, just moved,” or “This one is new,” or “This one was removed.” Without keys, React has to guess, which can cause unnecessary DOM updates, poor performance, or weird bugs like input fields losing focus. Keys act like a clear route map for React, helping it update only what actually changed and keep everything stable and efficient.

#### In React, some words are special and kept aside for React’s own use, and key is one of them. Think of it like a luggage tag at the airport—it’s used by the airport staff to track your bag, not by you once you land. In the same way, when you add a key to a React element, React reads it only for its internal tracking, to understand which item is which in a list. That key is not passed to the component as a normal prop, so the component itself can’t access it using props.key. It exists purely to help React manage updates efficiently behind the scenes, and once React finishes its job, the key is essentially invisible to your component. Keys are a property of the element itself, not something that needs to be passed along to the component!

#### the key must be placed on the outermost element that you return from the .map() function, not on any nested child inside it. When React processes a list created with .map(), it looks only at the top-level elements of that list to tell them apart from each other. If the key is placed deeper inside—on a child element—React can’t see it when comparing the list items, so it becomes useless for React’s tracking. By putting the key on the very first (outer) element returned in each iteration, you are clearly telling React, “This whole block is one unique item,” which allows React to correctly match items between renders and update the DOM efficiently without confusion or bugs.

#### When using fragments, it's sometimes required to switch to the long-form React.Fragment, so that we can apply the key. Keys only have to be unique within their array.

#### With the curly brackets, we can add JavaScript expressions within our JSX. Unfortunately, though, we can't add JavaScript statements:JSX is just a prettier way of writing React.createElement. When JSX is compiled, React doesn’t “run HTML”; it calls a function that creates plain JavaScript objects describing the UI. That function looks like this:React.createElement(type, props, children) Now here’s the key point: when you call a function, every argument must be a value. You can pass numbers, strings, objects, expressions—anything that evaluates to a value. But you cannot put an if statement inside a function call, because if is a statement, not a value. Statements control program flow, but they don’t produce something that can be passed as an argument.we can still use an if statement! But we have to pull it up so that it's not in the middle of a React.createElement call.

#### react ignores undefines completely.

#### The && operator doesn't return true or false. It returns either the left-hand side or the right-hand side. So, when our list is empty, this expression evaluates to 0.React will render any number you give it, even zero!React will ignore most falsy values like false or null, but it won't ignore the number zero.so ### To avoid having random 0 characters in our application, make sure that the left-hand side of && always evaluates to a boolean value, either true or false.The “greater than” operator (>) will always produce a boolean value, either true or false.DOM nodes memory consume karte hain sirf exist karne se, chahe wo visible hon ya nahi, isliye large apps me conditional rendering use karke extra nodes DOM se hata dena memory ke liye better hota hai.Lekin DOM node create ya destroy karna slow process hota hai, especially jab user baar-baar content show/hide karta ho.Isliye frequent toggles (jaise accordion) me CSS display use karna fast hota hai, aur rarely used content ke liye conditional rendering better hoti hai.