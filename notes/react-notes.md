# Day1
## we created a simple render function which takes react element and a container. React element is normal javascript object with type(which HTML Tag to create), props(contains HTML attributes) and children(text inside element)
## React elements are just JavaScript objects.
## Rendering means converting those objects into real DOM nodes.
## JSX and React APIs are abstractions over normal DOM operations.

## Instead of writing React.createElement, we use an HTML-like syntax to create React elements - JSX coz it is easier to read.
## React elements can form a tree structure, just like HTML elements This happens when we set the “children” parameter of a React element to another React element. In practice, we often wind up with pretty significant tree structures in our React code. Hence we use JSX coz HTML-like syntax is easier for our brains to process

## If we try to run this JSX code in the browser, we'll get an error. JavaScript engines don't understand JSX, they only understand JavaScript. And so we need to "compile" our code into plain JS.This is most commonly done as part of a build step, using a tool like BabelThe JSX we write gets converted into React.createElement. By the time our code is running in the user's browser, all of the JSX has been zapped out, and we're left with a JS file full of nested React.createElement calls.

## statements is action and expression produces a value. We can create expression slots with curly brackets ({}). Anything placed in-between curly brackets will be treated as pure JavaScript, instead of a string.
## use the multi-line comment syntax (/* */)

## htmlFor, className, JSX is case-sensitive,Our tags must all be lowercase. In JSX, our attributes need to be “camelCase.   data-test-id and aria-label are not camel case-exceptions.We can introduce white space in react using   {' '}
## We write React using JSX and imports because tools like Vite bundle and compile the code into browser-understandable JavaScript.

##  the browser cannot execute ES module imports without type="module", so React never runs.
## When we pass something between the open and close tags, React will automatically supply that value to us under children.It appears that React chooses to prioritize the children passed in-between the open/close tags

### The <dl> HTML tag is fairly obscure, but a super worthwhile tag!It stands for “Description List”, and it's intended to be used to display key/value pairs. For example, many e-commerce platforms will display product details in this format

#### React components are just JavaScript functions, and a function can return only one value. JSX may look like HTML, but it compiles into a single function call that creates one JavaScript object (a React element). When you try to return two or three React elements without a wrapper, you’re actually trying to return multiple JavaScript objects at once, which JavaScript simply doesn’t allow.One option is to wrap both React elements in a div but not recommended  It pollutes the DOM with unnecessary elements. And it can even lead to accessibility and layout issues.Hence we have React Fragments.Fragments allow us to respect the rules of JavaScript without polluting the HTML.A fragment is a special React component that does not produce a DOM node. 
#### There is one thing React does provide for us: we can pass an array, and React will unpack and render each item for us. For example, we can render {['hello', 'world']} and we'll see the content “helloworld” included in the DOM.React renders arrays by iterating over them and rendering each item as a sibling node.

#### When we give React an array of elements, we also need to help React out by uniquely identifying each element.so we have keys.why keys are necessary- React does not know specifically what happens when we change data All React sees is the before/after. Think of React like a person comparing two photos of the same room—one taken before a change and one after. React doesn’t see what action you took (added an item, removed one, or reordered them); it only sees the old snapshot and the new snapshot. Now imagine all the items in the room look similar—React won’t know which chair is the same chair as before unless each one has a name tag. That’s exactly what keys are. A key gives each item a permanent identity, so React can recognize, “This item is the same as before, just moved,” or “This one is new,” or “This one was removed.” Without keys, React has to guess, which can cause unnecessary DOM updates, poor performance, or weird bugs like input fields losing focus. Keys act like a clear route map for React, helping it update only what actually changed and keep everything stable and efficient.

#### In React, some words are special and kept aside for React’s own use, and key is one of them. Think of it like a luggage tag at the airport—it’s used by the airport staff to track your bag, not by you once you land. In the same way, when you add a key to a React element, React reads it only for its internal tracking, to understand which item is which in a list. That key is not passed to the component as a normal prop, so the component itself can’t access it using props.key. It exists purely to help React manage updates efficiently behind the scenes, and once React finishes its job, the key is essentially invisible to your component. Keys are a property of the element itself, not something that needs to be passed along to the component!

#### the key must be placed on the outermost element that you return from the .map() function, not on any nested child inside it. When React processes a list created with .map(), it looks only at the top-level elements of that list to tell them apart from each other. If the key is placed deeper inside—on a child element—React can’t see it when comparing the list items, so it becomes useless for React’s tracking. By putting the key on the very first (outer) element returned in each iteration, you are clearly telling React, “This whole block is one unique item,” which allows React to correctly match items between renders and update the DOM efficiently without confusion or bugs.

#### When using fragments, it's sometimes required to switch to the long-form React.Fragment, so that we can apply the key. Keys only have to be unique within their array.

#### With the curly brackets, we can add JavaScript expressions within our JSX. Unfortunately, though, we can't add JavaScript statements:JSX is just a prettier way of writing React.createElement. When JSX is compiled, React doesn’t “run HTML”; it calls a function that creates plain JavaScript objects describing the UI. That function looks like this:React.createElement(type, props, children) Now here’s the key point: when you call a function, every argument must be a value. You can pass numbers, strings, objects, expressions—anything that evaluates to a value. But you cannot put an if statement inside a function call, because if is a statement, not a value. Statements control program flow, but they don’t produce something that can be passed as an argument.we can still use an if statement! But we have to pull it up so that it's not in the middle of a React.createElement call.

#### react ignores undefines completely.

#### The && operator doesn't return true or false. It returns either the left-hand side or the right-hand side. So, when our list is empty, this expression evaluates to 0.React will render any number you give it, even zero!React will ignore most falsy values like false or null, but it won't ignore the number zero.so ### To avoid having random 0 characters in our application, make sure that the left-hand side of && always evaluates to a boolean value, either true or false.The “greater than” operator (>) will always produce a boolean value, either true or false.DOM nodes memory consume karte hain sirf exist karne se, chahe wo visible hon ya nahi, isliye large apps me conditional rendering use karke extra nodes DOM se hata dena memory ke liye better hota hai.Lekin DOM node create ya destroy karna slow process hota hai, especially jab user baar-baar content show/hide karta ho.Isliye frequent toggles (jaise accordion) me CSS display use karna fast hota hai, aur rarely used content ke liye conditional rendering better hoti hai.

#### A hook is a special type of function in React that allows a function component to access and use React’s built-in features, which are otherwise handled internally by React. When we say hooks “hook into React internals,” it means they connect our component to React’s internal systems such as state management, lifecycle behavior, and context. For example, hooks like useState let a function component store and update state, and useEffect lets it run side effects at specific points in the component’s lifecycle. Hooks make it possible to use these powerful React features without writing class components, resulting in cleaner, simpler, and more reusable code.

#### The useState hook returns an array containing two items:The current value of the state variable. and a function we can use to update the state variable. 
#### React state variables are given an initial value. We can supply a function also- called initializer function. React will call this functionon the very first render to calculate the initial value. t can occasionally be useful if we need to do an expensive operation to calculate the initial value. For example, reading from Local Storage:it's a way for us to save values on the user's device, so that it persists even after the browser tab is closed, and can be accessed on their next visit.The benefit here is that we're only doing the expensive work (reading from Local Storage) once, on the initial render, rather than doing it on every single render.

##### function Counter() {const [count, setCount] = React.useState(() => { return window.localStorage.getItem('saved-count'); });} we do it by wrapping it inside arrow function rather than directly putting it so that On the very first render, React will call this function to calculate the initial value. On subsequent renders, however, React ignores the function. The initial value has already been calculated, and so there's no reason to call the function again.

####  we update a state variable by calling the setter function (setCount), the UI gets updated. But how does this work, exactly?-In simple, everyday terms, you can think of each React render as taking a photo (or snapshot) of the UI at a particular moment. Every time something changes—like state or props—React creates a new snapshot that describes what the screen should look like now. For example, before clicking a button, the snapshot shows Value: 0, and after the click, a new snapshot shows Value: 1. React then compares the old photo with the new one, much like those “spot the difference” games where you look for what changed between two images. This comparison process is called reconciliation. Using smart and efficient algorithms, React figures out exactly what’s different between the two snapshots. Once it knows the differences, React carefully updates only those specific parts of the real webpage (the DOM) that need to change—nothing more. In this case, it simply updates the button text to Value: 1. This snapshot → compare → update cycle is the core flow that React follows to keep the UI fast and in sync with the data.Hence the name of the library-coz it reacts to changes.

#### Mount is the very first time a component appears on the screen. Since React has nothing to compare it with yet, it simply runs the component, creates all the required DOM elements from scratch, and places them on the page.Later, a trigger happens—usually a state update like calling setCount. This does not directly change the screen; it only tells React that some data has changed. Because of this change, React moves to the render phase, where it runs the component function again and creates a fresh description (snapshot) of what the UI should look like now. React then compares this new snapshot with the previous one to find what has changed. Finally, in the commit phase, React applies only those necessary changes to the real DOM—such as updating text, adding new elements, or removing old ones. After committing these updates, React becomes idle again and waits for the next state change to repeat the cycle.

### Trigger → Render (new snapshot) → Reconcile (compare) → Commit (update DOM) → Idle

### A re-render creates and compares UI snapshots inside React, but the browser only repaints when React actually changes the real DOM.Not all re-renders require re-paints! If nothing has changed between snapshots, React won't edit any DOM nodes, and nothing will be re-painted.