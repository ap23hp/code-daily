# Day1
#### we created a simple render function which takes react element and a container. React element is normal javascript object with type(which HTML Tag to create), props(contains HTML attributes) and children(text inside element)
#### React elements are just JavaScript objects.
#### Rendering means converting those objects into real DOM nodes.
#### JSX and React APIs are abstractions over normal DOM operations.

#### Instead of writing React.createElement, we use an HTML-like syntax to create React elements - JSX coz it is easier to read.
#### React elements can form a tree structure, just like HTML elements This happens when we set the “children” parameter of a React element to another React element. In practice, we often wind up with pretty significant tree structures in our React code. Hence we use JSX coz HTML-like syntax is easier for our brains to process

#### If we try to run this JSX code in the browser, we'll get an error. JavaScript engines don't understand JSX, they only understand JavaScript. And so we need to "compile" our code into plain JS.This is most commonly done as part of a build step, using a tool like BabelThe JSX we write gets converted into React.createElement. By the time our code is running in the user's browser, all of the JSX has been zapped out, and we're left with a JS file full of nested React.createElement calls.

#### statements is action and expression produces a value. We can create expression slots with curly brackets ({}). Anything placed in-between curly brackets will be treated as pure JavaScript, instead of a string.
#### use the multi-line comment syntax (/* */)

#### htmlFor, className, JSX is case-sensitive,Our tags must all be lowercase. In JSX, our attributes need to be “camelCase.   data-test-id and aria-label are not camel case-exceptions.We can introduce white space in react using   {' '}
#### We write React using JSX and imports because tools like Vite bundle and compile the code into browser-understandable JavaScript.

####  the browser cannot execute ES module imports without type="module", so React never runs.
#### When we pass something between the open and close tags, React will automatically supply that value to us under children.It appears that React chooses to prioritize the children passed in-between the open/close tags

#### The `<dl>` HTML tag is fairly obscure, but a super worthwhile tag!It stands for “Description List”, and it's intended to be used to display key/value pairs. For example, many e-commerce platforms will display product details in this format

#### React components are just JavaScript functions, and a function can return only one value. JSX may look like HTML, but it compiles into a single function call that creates one JavaScript object (a React element). When you try to return two or three React elements without a wrapper, you’re actually trying to return multiple JavaScript objects at once, which JavaScript simply doesn’t allow.One option is to wrap both React elements in a div but not recommended  It pollutes the DOM with unnecessary elements. And it can even lead to accessibility and layout issues.Hence we have React Fragments.Fragments allow us to respect the rules of JavaScript without polluting the HTML.A fragment is a special React component that does not produce a DOM node. 
#### There is one thing React does provide for us: we can pass an array, and React will unpack and render each item for us. For example, we can render {['hello', 'world']} and we'll see the content “helloworld” included in the DOM.React renders arrays by iterating over them and rendering each item as a sibling node.

#### When we give React an array of elements, we also need to help React out by uniquely identifying each element.so we have keys.why keys are necessary- React does not know specifically what happens when we change data All React sees is the before/after. Think of React like a person comparing two photos of the same room—one taken before a change and one after. React doesn’t see what action you took (added an item, removed one, or reordered them); it only sees the old snapshot and the new snapshot. Now imagine all the items in the room look similar—React won’t know which chair is the same chair as before unless each one has a name tag. That’s exactly what keys are. A key gives each item a permanent identity, so React can recognize, “This item is the same as before, just moved,” or “This one is new,” or “This one was removed.” Without keys, React has to guess, which can cause unnecessary DOM updates, poor performance, or weird bugs like input fields losing focus. Keys act like a clear route map for React, helping it update only what actually changed and keep everything stable and efficient.

#### In React, some words are special and kept aside for React’s own use, and key is one of them. Think of it like a luggage tag at the airport—it’s used by the airport staff to track your bag, not by you once you land. In the same way, when you add a key to a React element, React reads it only for its internal tracking, to understand which item is which in a list. That key is not passed to the component as a normal prop, so the component itself can’t access it using props.key. It exists purely to help React manage updates efficiently behind the scenes, and once React finishes its job, the key is essentially invisible to your component. Keys are a property of the element itself, not something that needs to be passed along to the component!

#### the key must be placed on the outermost element that you return from the .map() function, not on any nested child inside it. When React processes a list created with .map(), it looks only at the top-level elements of that list to tell them apart from each other. If the key is placed deeper inside—on a child element—React can’t see it when comparing the list items, so it becomes useless for React’s tracking. By putting the key on the very first (outer) element returned in each iteration, you are clearly telling React, “This whole block is one unique item,” which allows React to correctly match items between renders and update the DOM efficiently without confusion or bugs.

#### When using fragments, it's sometimes required to switch to the long-form React.Fragment, so that we can apply the key. Keys only have to be unique within their array.

#### With the curly brackets, we can add JavaScript expressions within our JSX. Unfortunately, though, we can't add JavaScript statements:JSX is just a prettier way of writing React.createElement. When JSX is compiled, React doesn’t “run HTML”; it calls a function that creates plain JavaScript objects describing the UI. That function looks like this:React.createElement(type, props, children) Now here’s the key point: when you call a function, every argument must be a value. You can pass numbers, strings, objects, expressions—anything that evaluates to a value. But you cannot put an if statement inside a function call, because if is a statement, not a value. Statements control program flow, but they don’t produce something that can be passed as an argument.we can still use an if statement! But we have to pull it up so that it's not in the middle of a React.createElement call.

#### react ignores undefines completely.

#### The && operator doesn't return true or false. It returns either the left-hand side or the right-hand side. So, when our list is empty, this expression evaluates to 0.React will render any number you give it, even zero!React will ignore most falsy values like false or null, but it won't ignore the number zero.so ### To avoid having random 0 characters in our application, make sure that the left-hand side of && always evaluates to a boolean value, either true or false.The “greater than” operator (>) will always produce a boolean value, either true or false.DOM nodes memory consume karte hain sirf exist karne se, chahe wo visible hon ya nahi, isliye large apps me conditional rendering use karke extra nodes DOM se hata dena memory ke liye better hota hai.Lekin DOM node create ya destroy karna slow process hota hai, especially jab user baar-baar content show/hide karta ho.Isliye frequent toggles (jaise accordion) me CSS display use karna fast hota hai, aur rarely used content ke liye conditional rendering better hoti hai.

#### A hook is a special type of function in React that allows a function component to access and use React’s built-in features, which are otherwise handled internally by React. When we say hooks “hook into React internals,” it means they connect our component to React’s internal systems such as state management, lifecycle behavior, and context. For example, hooks like useState let a function component store and update state, and useEffect lets it run side effects at specific points in the component’s lifecycle. Hooks make it possible to use these powerful React features without writing class components, resulting in cleaner, simpler, and more reusable code.

#### The useState hook returns an array containing two items:The current value of the state variable. and a function we can use to update the state variable. 
#### React state variables are given an initial value. We can supply a function also- called initializer function. React will call this functionon the very first render to calculate the initial value. t can occasionally be useful if we need to do an expensive operation to calculate the initial value. For example, reading from Local Storage:it's a way for us to save values on the user's device, so that it persists even after the browser tab is closed, and can be accessed on their next visit.The benefit here is that we're only doing the expensive work (reading from Local Storage) once, on the initial render, rather than doing it on every single render.

##### function Counter() {const [count, setCount] = React.useState(() => { return window.localStorage.getItem('saved-count'); });} we do it by wrapping it inside arrow function rather than directly putting it so that On the very first render, React will call this function to calculate the initial value. On subsequent renders, however, React ignores the function. The initial value has already been calculated, and so there's no reason to call the function again.
#### Functions passed to event handlers must be passed, not called.
####  we update a state variable by calling the setter function (setCount), the UI gets updated. But how does this work, exactly?-In simple, everyday terms, you can think of each React render as taking a photo (or snapshot) of the UI at a particular moment. Every time something changes—like state or props—React creates a new snapshot that describes what the screen should look like now. For example, before clicking a button, the snapshot shows Value: 0, and after the click, a new snapshot shows Value: 1. React then compares the old photo with the new one, much like those “spot the difference” games where you look for what changed between two images. This comparison process is called reconciliation. Using smart and efficient algorithms, React figures out exactly what’s different between the two snapshots. Once it knows the differences, React carefully updates only those specific parts of the real webpage (the DOM) that need to change—nothing more. In this case, it simply updates the button text to Value: 1. This snapshot → compare → update cycle is the core flow that React follows to keep the UI fast and in sync with the data.Hence the name of the library-coz it reacts to changes.

#### Mount is the very first time a component appears on the screen. Since React has nothing to compare it with yet, it simply runs the component, creates all the required DOM elements from scratch, and places them on the page.Later, a trigger happens—usually a state update like calling setCount. This does not directly change the screen; it only tells React that some data has changed. Because of this change, React moves to the render phase, where it runs the component function again and creates a fresh description (snapshot) of what the UI should look like now. React then compares this new snapshot with the previous one to find what has changed. Finally, in the commit phase, React applies only those necessary changes to the real DOM—such as updating text, adding new elements, or removing old ones. After committing these updates, React becomes idle again and waits for the next state change to repeat the cycle.

#### Trigger → Render (new snapshot) → Reconcile (compare) → Commit (update DOM) → Idle
#### React state updates are asynchronous because when we call a state setter, React does not update the state immediately. Instead, React notes down the change, schedules an update, and then creates a new snapshot of the UI. It compares this new snapshot with the previous one, figures out what has changed, and only updates those parts of the DOM. After that, the browser repaints the screen. Because this whole process happens later, if we log the state immediately after calling the setter, we often see the previous state, not the updated one.
#### Re-rendering in React does not mean that the browser immediately redraws the screen. A re-render means that React calls your component function again and creates a new “snapshot” of the UI using the latest state and props. This whole process happens inside React and is an abstract, internal step. The user does not see anything changing at this stage. After React creates this new snapshot, it performs reconciliation, where it compares the new snapshot with the previous one to figure out what has actually changed. Only after this comparison does React update the real DOM. Finally, the browser repaints the screen based on those DOM updates, and that is the part the user actually sees.

#### When multiple state updates happen inside the same event (like clicking a “Log Out” button), React does not update the UI immediately for each one. Instead, it notes down all the changes, batches them together, and performs one single re-render after the event handler finishes. This is important for both performance and correctness. If state updates were synchronous, React would re-render after every setState call, doing unnecessary extra work and potentially showing broken UI—for example, updating user to null before the confirmation message is ready, resulting in empty or inconsistent content. By keeping state updates asynchronous and batched, React ensures the UI updates once, efficiently, and in a consistent final state, even though it can be confusing at first when logging state values immediately after setting them.
#### A re-render creates and compares UI snapshots inside React, but the browser only repaints when React actually changes the real DOM.Not all re-renders require re-paints! If nothing has changed between snapshots, React won't edit any DOM nodes, and nothing will be re-painted.
#### so first step is to create a form component that will render form- inputs. Next we create states using useState, then inside the state we use object to give values to out multiple inputs. otherwise we would have to make a lot of states in case of multiple inputs. Then we bind out form input by using value attribute and in this value attribute we put state for that perticular input from out state object. Then on the inputs we use name attribute to give them the same name as our states. Till here half binding is done. Now on chnage of input user should be able to type and we should be able to see thta. so we do that by writing onChnage on the input. In select type of input always remeber we put onChnage , value and name on the select . Now onChnage will do these things--> first it will be getting an event object from the browser the moment anyone tries to type in input. next we will target the input using e.target.value and e.target.name. This will give us the value and the input with which the value is attached. Next onChnage of input we need to change the value. so setState function will be called and we will pass updated object of state in it using spread operator in which we will get old objecta dn we will pass whatever new has chnaged. This was we do not muttate the state object directly

####  React 19 introduced Actions as a new way to handle form submissions. In the classic method, we use controlled inputs, where each form field is connected to React state using useState and updated with onChange handlers. This allows React to know the value of each input in real time, making it easy to show live previews, validations, or instant feedback while the user is typing. When the form is submitted, an onSubmit function handles sending the collected state data to the server and managing loading or error states. Actions are a new way to handle form submission in React 19 without using useState for every input.With Actions:React itself collects all input values when the form is submitted , You work with the data only at submit time Instead of tracking input values while the user is typing, React waits until the form is submitted and then automatically collects all the input data for us. In the code, useActionState gives us three things: the current result or error, a function called submitAction that runs when the form is submitted, and a boolean isPending that tells us whether the submission is still in progress. Instead of using onSubmit, we pass submitAction to the form using action={submitAction}, which means “run this action when the form is submitted.” The input fields are uncontrolled, meaning they don’t use value or onChange; they only need a name attribute so React can read their values from formData at submit time. This makes forms less verbose and easier to write, especially large ones, but because the data is only available on submit, Actions are not suitable for cases where we need real-time access to input values, such as live search or instant previews.

#### Forms reload the page by default because of legacy browser behavior. event.preventDefault(). It stops the browser from executing a full page reload.

#### All form controls in React follow the same basic pattern: the current value of the input is locked using either the `value` attribute (for text inputs, textareas, selects, sliders, color pickers, etc.) or the `checked` attribute (for checkboxes and radio buttons), and any change made by the user is handled through the `onChange` event, which updates React state. For text inputs and textareas, controlled components bind state to `value`,
#### while uncontrolled components can use `defaultValue` to set an initial value. It is important to always initialize state with a valid value (usually an empty string for text inputs) to avoid bugs caused by switching from uncontrolled to controlled inputs. 

#### Radio buttons are controlled using a boolean `checked` value and typically share the same `name` attribute so only one option can be selected, while checkboxes also rely on `checked`, storing either a single boolean for one checkbox or an object-like structure for multiple checkboxes. 
#### Select dropdowns work like text inputs, using `value` and `onChange`, and the initial state must exactly match one of the option values to prevent unexpected behavior. 
#### Specialty inputs such as range sliders, date pickers, and color pickers follow the same controlled pattern as text inputs, with the important caveat that input values from the DOM are always strings, even for numeric inputs, so conversion may be required. 
#### Finally, because forms reload the page by default, modern React applications always call `event.preventDefault()` on submit to stop the browser’s default behavior and allow React to handle updates smoothly without a full page refresh.

#### React uses a synthetic event system, which means the events we receive in React are special objects created by React, not the browser’s native JavaScript events. React does this to provide consistent behavior across different browsers, avoiding edge-case differences in how native events work. These synthetic events also improve the developer experience by offering a uniform and predictable API. Earlier versions of React used this system for performance optimizations like event pooling, but this was removed in React 17, so features like event.persist() are no longer needed. If required, the original browser event can still be accessed using event.nativeEvent.Different browsers do not implement events in exactly the same way.The event object, its properties, and even when an event fires can vary slightly between Chrome, Firefox, Safari, Edge, etc.React’s synthetic event system normalizes these differences, so you write one kind of code and it works the same everywhere.

#### Props allow us to customize the behaviour of a given component, so that the exact same component can do different things in different scenarios.Props are the inputs to our components, like arguments passed to a function .React state is used to track data that changes over time By default, state is only made available to the current component. so props: they're the tunnels that allow data to flow through our application.
#### Never mutate React state, even if it appears to work, because React relies on the assumption that state values are treated as immutable.he correct approach is always to create a new copy of the state first, apply changes to that copy, and then pass the new value to the state setter. While some developers worry that creating new arrays or objects on every update might be inefficient, in practice this cost is negligible—modern JavaScript engines can clone arrays extremely quickly, even on low-end hardware, and the time taken is far below what humans can perceive. As a result, immutability is not only safer and more predictable, but also fast enough for real-world front-end applications, making it the correct and recommended way to manage React state.

#### Setting a React list key to Math.random() may remove the warning, but it introduces a serious performance problem because the key changes on every render. Since Math.random() generates a new value each time, React thinks that every item in the list is completely new whenever the component re-renders. As a result, even if only one new item is added, React deletes all existing DOM elements and recreates them from scratch instead of updating only what actually changed. Because DOM operations are relatively expensive, this unnecessary destruction and recreation can significantly hurt performance. The correct idea is not to avoid randomness altogether, but to ensure that the key remains stable across renders. This can be achieved by generating the random ID once—at the moment the item is created, such as inside a click handler—and storing it with the item’s data. In this way, React can reliably identify which items are unchanged and update only the new ones. Besides Math.random(), safer alternatives like crypto.randomUUID() can also be used to generate unique, stable identifiers.

#### In simple terms, keys help React recognize which item is which in a list. If we use the array index or something like the list length as a key, React can get confused when items are added, removed, or moved, and it may update or delete the wrong elements on the screen. This can cause weird bugs and extra work for the browser. While using indexes might seem fine when the list never changes, it’s easy to be wrong about that. That’s why it’s safer to give each item its own unique and fixed ID so React always knows exactly what has changed.

#### In React, data (state) can only move in one direction, like water flowing downhill — from a parent component to its child components using props. Two sibling components cannot talk to each other directly or share data on their own. So if both siblings need the same information, the only solution is to keep that information in their common parent. The parent then shares the state with both children and can also pass the function that updates the state, so children are allowed to change it.Here’s how it works in real life: when a user types something into a textbox, a change event happens. That change calls a state-update function which actually belongs to the parent component. Because the parent owns the state, updating it causes the parent to re-render, and when the parent re-renders, all its children re-render too. One child (the form) gets the updated value and shows it in the input, while the other child (the results) also receives the same updated value and displays it wherever needed.Now, you might wonder — why not just put all state at the very top of the app? The reason is that doing this in larger apps makes everything slow and messy. Too much state at the top causes unnecessary re-renders and makes the code hard to understand and maintain. That’s why in React, we only “lift state up” when it’s actually shared, not everywhere.

#### parent passes down a function so that the child can update the parent's state
#### Think of a React component like a real object, not just some JSX on the screen. When a component appears on the page for the first time, React “mounts” it, which means two things happen: React turns the JSX into real DOM elements, and at the same time it creates a component instance—a little invisible box that belongs only to that component. This box is where React stores things like state. When we use useState, we’re not storing data in the JSX or in some global place; we’re simply reading from and writing to this component’s own instance box. If the component disappears from the screen because of conditional rendering, React “unmounts” it, which destroys that box and all the state inside it is lost. And because every component on the screen gets its own instance box, React can show multiple copies of the same component, with each copy remembering its own state independently.

#### In React, one important idea is that components are reusable, meaning we should be able to use the same component multiple times on a page without any problems. However, some parts of the web don’t naturally support reusability. For example, HTML id attributes must be unique across the entire page, so if the same component is rendered more than once, it can accidentally create duplicate IDs and cause bugs or accessibility issues. One option is to pass a unique id as a prop, but this relies on the developer remembering to do it correctly every time, which is not very reliable. To solve this problem, React provides the useId hook, which automatically generates a unique ID for each component instance. When a component uses useId, React gives each instance its own stable ID that stays the same across re-renders. Additionally, useId is designed to generate the same ID on both the server and the client, which is especially important for server-side rendering. This makes it a safe and convenient way to handle unique IDs in reusable React components without extra effort or mistakes.n SSR, a React component is rendered once on the server to generate HTML and then rendered again in the browser during hydration. If the IDs generated on the server and client do not match, React can produce warnings or cause UI inconsistencies. useId solves this problem by ensuring that each component instance receives a stable ID that remains consistent across renders and environments, making it safe for reusable components, accessibility attributes, and server-rendered applications.

#### So, we've talked about how hooks are special functions that allow us to “hook” into React internals. useState allows us to hook into a component instance's state, for example, while useId allows us to create and store a unique identifier on the component instance.

#### React has a strict rule that hooks must always be called in the same order on every render. This is because React does not identify hooks by name or ID—instead, it remembers them by the order in which they are called. For example, if a component calls useState first and then another useState, React assumes the first call is always for the first state and the second call is always for the second state. If this order changes between renders, React gets confused and can assign the wrong state to the wrong variable, leading to very strange bugs.This is why hooks are never allowed inside if conditions, loops, or callbacks.

#### Hooks in React must be called inside a React component because hooks are designed to work with React’s internal system that tracks component state and behavior. If we try to call a hook outside a component—like in a normal JavaScript function—React won’t know which component that hook belongs to, so it can’t manage state or effects correctly.Hooks also must be called at the top level of a component, not inside conditions, loops, or nested functions. This is because React relies on the order in which hooks are called to keep track of their values between renders. If hooks were called conditionally, that order could change, and React would get confused about which state or effect belongs to which hook. By always calling hooks at the top level, we ensure that React can reliably match each hook to the correct component instance on every render.

#### eact treats state as immutable, meaning we don’t directly change existing objects but instead create new ones when updating state. For example, instead of mutating an object like user.name = 'Ava', React creates a new object using setUser({ name: 'Ava' }), which lives in a different place in memory while the old one still exists briefly. JavaScript stores objects by reference, so even identical-looking objects are considered different if they are created separately. When a component has multiple state variables, React only creates new objects for the state that actually changes and reuses the same references for the rest. This allows React to efficiently detect changes and is the foundation for how hooks like useEffect, useMemo, and useCallback decide when to run.

#### a component instance is a JavaScript object that is the “source of truth” for everything related to a particular instance of a component. It's created when the component is mounted, and it persists until the component is unmounted.

#### A snapshot, by contrast, is not a specific JavaScript object. It's a more abstract/metaphorical concept. It refers to the data available at a moment in time.So, we might say that an instance holds the true value of a piece of state, but every time that state changes, we create a snapshot that captures the current value of that state variable.

#### Local variables don’t persist between renders. When React renders this component a second time, it renders it from scratch—it doesn’t consider any changes to the local variables.Changes to local variables won’t trigger renders. React doesn’t realize it needs to render the component again with the new data.To update a component with new data, two things need to happen:Retain the data between renders.Trigger React to render the component with new data (re-rendering).The useState Hook provides those two things:A state variable to retain the data between renders.A state setter function to update the variable and trigger React to render the component again.

#### On the web, user interfaces are usually built using standard HTML elements like divs, buttons, and forms, where the browser handles how everything looks and behaves. However, there is another powerful way to create visuals on the web using HTML Canvas, which works more like a drawing board. With Canvas, we don’t create UI elements—instead, we use JavaScript to manually draw shapes, pixels, and animations, similar to how Microsoft Paint works. This approach is especially useful for animations, visual effects, particle systems, and games, where we need full control over every frame. Unlike normal DOM-based animations, Canvas requires redrawing the scene again and again using JavaScript, usually with requestAnimationFrame. React is typically used to manage application logic and state, while Canvas handles the visual rendering, making it a great choice for complex and high-performance animations.

#### When we use React, it likes to stay in full control of the UI. We don’t directly touch the real DOM because React manages it for us using its own system, deciding when and how elements should update. If we use something like document.querySelector, we are directly grabbing elements from the browser without React knowing, which means we are going behind React’s back and bypassing its system. This can cause problems because React might re-render or replace those elements later, and our reference can break. To avoid this, React provides refs, which are a safe and approved way to access DOM elements when really needed, such as for working with a canvas. Using useRef, React gives us the DOM element and keeps it updated across renders, allowing us to work with it without breaking React’s flow or causing unexpected bugs.the useRef hook, which creates a persistent container that holds the DOM reference across renders. React fills this container only once when the component mounts, and we can safely access the DOM node later—such as inside a button click handler—without causing extra work. This makes useRef the recommended and performant way to work with DOM elements like canvas in React.

#### When we call React.useRef, we're given an object with a current property.If we pass an object with this shape to the ref attribute, React will mutate this object, setting current equal to the canvas reference.This only runs when the component first renders, leading to improved performance.This is the conventional way to work with DOM node references in React!
### Basically, we use the useRef hook to create a ref “box” that can hold a value. This ref box is an object with a current property, which is initially undefined. We then attach this ref box to a DOM element using the ref attribute. When React renders the component, it automatically puts the actual DOM element into the current property of the ref box. After that, whenever we need to access that DOM element—for example, inside a click handler or an effect—we can simply use domElementRef.current. This lets us safely work with DOM elements without bypassing React’s system.

#### React me useRef tab useful hota hai jab humein kisi real DOM element ko directly control karna hota hai, jaise audio, video, input, ya canvas. useRef sirf ek container deta hai jiska current actual DOM element ko point karta hai, lekin kaam tab hota hai jab humein us DOM element ki native properties aur methods pata hon — jaise <audio> ke play(), pause(), currentTime, volume, ya <input> ke focus(), value, etc. Isliye sirf React hooks samajhna kaafi nahi hota; problems solve karne ke liye HTML/DOM elements ki properties aur methods bhi aani chahiye, jo aksar Google/MDN se dekhni padti hain. React bas bridge hai — actual power DOM APIs me hoti hai.

#### As we build applications, we often need to synchronize with external systems. This can include things like: Making network requests Managing timeouts / intervals Reading/writing from localStorage Listening for global events window resize or keyboard input React calls all of these things “side effects”

#### React’s core responsibility is to keep the DOM in sync with JSX by re-rendering whenever state or props change, but not all logic fits into this render cycle. Tasks like updating the document title, interacting with localStorage, or making network requests exist outside React’s main job and are known as side effects. To manage these safely and predictably, React provides the useEffect hook, which allows us to run side-effect logic after a component has rendered. By passing a dependency array to useEffect, we can control when the effect runs—for example, specifying [count] ensures the effect only re-runs when the count value changes. Importantly, effects always run after the first render, ensuring the component is fully mounted before any side-effect logic executes.

#### Event handlers belong in render scope.Side effects belong in useEffect.

#### useEffect runs after React has finished rendering and updating the DOM. It always runs once after the very first render, ensuring the component is mounted before any side-effect logic executes. After that initial run, useEffect will run again whenever one of the values listed in its dependency array changes; if the dependency array is empty, the effect runs only once on mount, and if no dependency array is provided, the effect runs after every render. In development mode with React Strict Mode enabled, effects may run twice on the initial mount to help detect side-effect bugs, but this behavior does not occur in production.

#### React ka Strict Mode development ke time component ko jaan-boojh kar do baar start aur stop karta hai, taaki yeh check kar sake ki humne apne side effects ko theek se clean up kiya hai ya nahi. Agar useEffect ke andar hum koi cheez start karte hain—jaise timer, event listener, ya subscription—but usse band karne ka cleanup function nahi likhte, toh pehle wala effect background me chalta rehta hai. Jab component dobara mount hota hai, ek naya effect phir se start ho jaata hai, aur isse bugs jaise duplicate logs, multiple API calls, ya memory leaks saamne aa jaate hain. Is tarah Strict Mode humein pehle hi warn kar deta hai ki production me jaakar problem aa sakti hai.

#### in strict mode : mount → interval start Then unmount → cleanup runs → interval cleared  Then mount again → fresh interval start

#### In Strict Mode, React will automatically re-run certain chunks of code, while we're working on our applications. This is done to highlight potential issues.--> In React Strict Mode, useEffect is intentionally run twice during development, but each run is separated by a cleanup. If an effect starts something like a timer, event listener, or subscription and the cleanup function is written correctly, the first effect is properly stopped before the second one runs, so no duplicate behavior appears. However, if the cleanup is missing, the first effect continues running in the background, and when Strict Mode runs the effect again, a second instance is added on top of it. This results in duplicate logs, repeated API calls, or multiple timers, which clearly signals a bug. In short, Strict Mode doesn’t expose bugs because effects run twice—it exposes bugs when cleanup is missing and behavior runs twice.

#### Values stored in localStorage are always saved as strings, regardless of their original data type, so booleans like true or false are stored as "true" and "false". Because of this, when retrieving a value from localStorage, we must convert it back to its original type before using it in our application. A common and reliable way to do this is by using JSON.parse(), which correctly converts stored strings like "true" or "false" back into boolean values. Similarly, when saving values to localStorage, we should use JSON.stringify() to ensure the data is stored in a valid and consistent string format, preventing errors and making the data safe to read later.

#### In React, we can use a function to initialize a state variable by passing a function to useState instead of a direct value. This is called lazy initialization, and it allows the initialization logic to run only once, when the component first renders, rather than on every re-render. This is especially useful when the initial state depends on an expensive operation or external data, such as reading a value from localStorage, because it improves performance and avoids unnecessary repeated work.

#### React shows an ESLint warning because the useEffect hook uses the count state variable but does not include it in the dependency array. This rule exists to prevent effects from becoming out of sync with the rest of the component. Each time setCount is called, React re-renders the component and creates a new “snapshot” of state, meaning a new version of the count variable exists for that render. When count is missing from the dependency array, the effect becomes frozen in time and continues to reference the initial version of count (which was 0), even though the UI and other parts of the component are using the updated value. This leads to confusing behavior where multiple versions of the same state appear to exist at once. By adding count to the dependency array, we ensure the effect re-runs whenever count changes, keeping the effect synchronized with the component’s state and preventing subtle bugs.

#### To build an auto-focusing text input in React, we first need a reference to the actual input DOM element, which we can get using the useRef hook. While input elements provide a .focus() method, we cannot call it directly during render because the ref is still empty at that point—the DOM node doesn’t exist until after the first render completes. Attempting to focus the input during render results in an error since inputRef.current is still undefined. The correct solution is to use the useEffect hook, which runs after React has finished rendering and attaching refs. By placing the focus logic inside useEffect and providing an empty dependency array, we ensure that the effect runs only once, immediately after the component mounts, allowing the input to receive focus safely and reliably.

#### HTML form inputs have an autofocus property that can be used to automatically focus the element on page load: <input autofocus type="text" /> Given that there's a built-in way to auto-focus an input, why are we going through all the trouble with useRef and useEffect?? Unfortunately, it isn't safe to use the autofocus attribute in React. The autofocus attribute only works reliably if the element is present when the page first loads. It won't work if the element is dynamically injected into the page afterwards. And in React, pretty much every element is dynamically injected! The only exception is if you use server-side rendering, and even then, only for the very first page the user visits on your site. And so, the solution shown above, capturing an input with a ref and triggering .focus() in an effect, is the best way to solve this problem in React.

#### When we use things like window.addEventListener, we are signing up for something that keeps running in the background, such as listening to mouse movements. If we put this code inside useEffect without a dependency array, React will run it after every render, which means we accidentally add the same event listener again and again. Since mouse movement itself causes re-renders, this can quickly lead to many duplicate listeners running at the same time. To prevent this, we pass an empty dependency array to useEffect, which tells React to run the effect only once, when the component first appears on the screen. This way, we set up the listener a single time instead of repeatedly, avoiding bugs and performance problems.

#### When we use useEffect to start long-running processes like event listeners, timers, or subscriptions, those processes do not automatically stop when a component unmounts. In the mouse-tracking example, the MouseTracker component adds a global mousemove event listener when it mounts, but when the component is conditionally removed from the UI, the listener keeps running in the background. This causes two serious problems: each time the component is re-mounted, a new event listener is added without removing the old one, and because the listener still references the component’s state updater, the JavaScript garbage collector cannot clean up the old component instance, leading to a memory leak. React cannot remove these listeners automatically because it cannot see what happens inside the effect, and the browser’s event system also has no awareness of React components. To solve this, useEffect allows us to return a cleanup function, which React calls just before the component unmounts. By unsubscribing from the event listener in this cleanup function, we properly stop the long-running process, keep React and the DOM in sync, and prevent memory leaks.

#### React does not run the cleanup function immediately because the effect is meant to start a process and keep it running while the component is active. If React were to execute the cleanup as soon as the effect returns it, the effect would be stopped instantly and long-running processes like event listeners or timers would never actually work. Instead, React stores the cleanup function and runs it later at the correct time—either right before the component unmounts or before the effect runs again due to a dependency change. This design keeps React’s rendering predictable and ensures side effects start and stop at safe, well-defined moments.
