# Day1
#### we created a simple render function which takes react element and a container. React element is normal javascript object with type(which HTML Tag to create), props(contains HTML attributes) and children(text inside element)
#### React elements are just JavaScript objects.
#### Rendering means converting those objects into real DOM nodes.
#### JSX and React APIs are abstractions over normal DOM operations.

#### Instead of writing React.createElement, we use an HTML-like syntax to create React elements - JSX coz it is easier to read.
#### React elements can form a tree structure, just like HTML elements This happens when we set the “children” parameter of a React element to another React element. In practice, we often wind up with pretty significant tree structures in our React code. Hence we use JSX coz HTML-like syntax is easier for our brains to process

#### If we try to run this JSX code in the browser, we'll get an error. JavaScript engines don't understand JSX, they only understand JavaScript. And so we need to "compile" our code into plain JS.This is most commonly done as part of a build step, using a tool like BabelThe JSX we write gets converted into React.createElement. By the time our code is running in the user's browser, all of the JSX has been zapped out, and we're left with a JS file full of nested React.createElement calls.

#### statements is action and expression produces a value. We can create expression slots with curly brackets ({}). Anything placed in-between curly brackets will be treated as pure JavaScript, instead of a string.
#### use the multi-line comment syntax (/* */)

#### htmlFor, className, JSX is case-sensitive,Our tags must all be lowercase. In JSX, our attributes need to be “camelCase.   data-test-id and aria-label are not camel case-exceptions. data-* and aria-* attributes are special exceptions because they follow web and accessibility standards and must remain hyphenated to work correctly. We can introduce white space in react using   {' '}
#### We write React using JSX and imports because tools like Vite bundle and compile the code into browser-understandable JavaScript.

####  the browser cannot execute ES module imports without type="module", so React never runs.
#### When we pass something between the open and close tags, React will automatically supply that value to us under children.It appears that React chooses to prioritize the children passed in-between the open/close tags

#### The `<dl>` HTML tag is fairly obscure, but a super worthwhile tag!It stands for “Description List”, and it's intended to be used to display key/value pairs. For example, many e-commerce platforms will display product details in this format

#### React components are just JavaScript functions, and a function can return only one value. JSX may look like HTML, but it compiles into a single function call that creates one JavaScript object (a React element). When you try to return two or three React elements without a wrapper, you’re actually trying to return multiple JavaScript objects at once, which JavaScript simply doesn’t allow.One option is to wrap both React elements in a div but not recommended  It pollutes the DOM with unnecessary elements. And it can even lead to accessibility and layout issues.Hence we have React Fragments.Fragments allow us to respect the rules of JavaScript without polluting the HTML.A fragment is a special React component that does not produce a DOM node. 
#### There is one thing React does provide for us: we can pass an array, and React will unpack and render each item for us. For example, we can render {['hello', 'world']} and we'll see the content “helloworld” included in the DOM.React renders arrays by iterating over them and rendering each item as a sibling node.

#### When we give React an array of elements, we also need to help React out by uniquely identifying each element.so we have keys.why keys are necessary- React does not know specifically what happens when we change data All React sees is the before/after. Think of React like a person comparing two photos of the same room—one taken before a change and one after. React doesn’t see what action you took (added an item, removed one, or reordered them); it only sees the old snapshot and the new snapshot. Now imagine all the items in the room look similar—React won’t know which chair is the same chair as before unless each one has a name tag. That’s exactly what keys are. A key gives each item a permanent identity, so React can recognize, “This item is the same as before, just moved,” or “This one is new,” or “This one was removed.” Without keys, React has to guess, which can cause unnecessary DOM updates, poor performance, or weird bugs like input fields losing focus. Keys act like a clear route map for React, helping it update only what actually changed and keep everything stable and efficient.

#### In React, some words are special and kept aside for React’s own use, and key is one of them. Think of it like a luggage tag at the airport—it’s used by the airport staff to track your bag, not by you once you land. In the same way, when you add a key to a React element, React reads it only for its internal tracking, to understand which item is which in a list. That key is not passed to the component as a normal prop, so the component itself can’t access it using props.key. It exists purely to help React manage updates efficiently behind the scenes, and once React finishes its job, the key is essentially invisible to your component. Keys are a property of the element itself, not something that needs to be passed along to the component!

#### the key must be placed on the outermost element that you return from the .map() function, not on any nested child inside it. When React processes a list created with .map(), it looks only at the top-level elements of that list to tell them apart from each other. If the key is placed deeper inside—on a child element—React can’t see it when comparing the list items, so it becomes useless for React’s tracking. By putting the key on the very first (outer) element returned in each iteration, you are clearly telling React, “This whole block is one unique item,” which allows React to correctly match items between renders and update the DOM efficiently without confusion or bugs.

#### When using fragments, it's sometimes required to switch to the long-form React.Fragment, so that we can apply the key. Keys only have to be unique within their array.

#### With the curly brackets, we can add JavaScript expressions within our JSX. Unfortunately, though, we can't add JavaScript statements:JSX is just a prettier way of writing React.createElement. When JSX is compiled, React doesn’t “run HTML”; it calls a function that creates plain JavaScript objects describing the UI. That function looks like this:React.createElement(type, props, children) Now here’s the key point: when you call a function, every argument must be a value. You can pass numbers, strings, objects, expressions—anything that evaluates to a value. But you cannot put an if statement inside a function call, because if is a statement, not a value. Statements control program flow, but they don’t produce something that can be passed as an argument.we can still use an if statement! But we have to pull it up so that it's not in the middle of a React.createElement call.

#### react ignores undefines completely.

#### The && operator doesn't return true or false. It returns either the left-hand side or the right-hand side. So, when our list is empty, this expression evaluates to 0.React will render any number you give it, even zero!React will ignore most falsy values like false or null, but it won't ignore the number zero.so ### To avoid having random 0 characters in our application, make sure that the left-hand side of && always evaluates to a boolean value, either true or false.The “greater than” operator (>) will always produce a boolean value, either true or false.DOM nodes memory consume karte hain sirf exist karne se, chahe wo visible hon ya nahi, isliye large apps me conditional rendering use karke extra nodes DOM se hata dena memory ke liye better hota hai.Lekin DOM node create ya destroy karna slow process hota hai, especially jab user baar-baar content show/hide karta ho.Isliye frequent toggles (jaise accordion) me CSS display use karna fast hota hai, aur rarely used content ke liye conditional rendering better hoti hai.

#### A hook is a special type of function in React that allows a function component to access and use React’s built-in features, which are otherwise handled internally by React. When we say hooks “hook into React internals,” it means they connect our component to React’s internal systems such as state management, lifecycle behavior, and context. For example, hooks like useState let a function component store and update state, and useEffect lets it run side effects at specific points in the component’s lifecycle. Hooks make it possible to use these powerful React features without writing class components, resulting in cleaner, simpler, and more reusable code.Even though hooks look like normal functions, they must follow specific rules: they can only be called inside React function components or custom hooks, and they must be called at the top level so React can track them correctly. So, while hooks are technically functions, they are tightly controlled by React and behave differently from regular JavaScript functions.

#### The useState hook returns an array containing two items:The current value of the state variable. and a function we can use to update the state variable. 
#### React state variables are given an initial value. We can supply a function also- called initializer function. React will call this functionon the very first render to calculate the initial value. t can occasionally be useful if we need to do an expensive operation to calculate the initial value. For example, reading from Local Storage:it's a way for us to save values on the user's device, so that it persists even after the browser tab is closed, and can be accessed on their next visit.The benefit here is that we're only doing the expensive work (reading from Local Storage) once, on the initial render, rather than doing it on every single render.It’s called “expensive” because some operations take noticeable time or resources for the browser to complete

##### function Counter() {const [count, setCount] = React.useState(() => { return window.localStorage.getItem('saved-count'); });} we do it by wrapping it inside arrow function rather than directly putting it so that On the very first render, React will call this function to calculate the initial value. On subsequent renders, however, React ignores the function. The initial value has already been calculated, and so there's no reason to call the function again.
#### Functions passed to event handlers must be passed, not called.
####  we update a state variable by calling the setter function (setCount), the UI gets updated. But how does this work, exactly?-In simple, everyday terms, you can think of each React render as taking a photo (or snapshot) of the UI at a particular moment. Every time something changes—like state or props—React creates a new snapshot that describes what the screen should look like now. For example, before clicking a button, the snapshot shows Value: 0, and after the click, a new snapshot shows Value: 1. React then compares the old photo with the new one, much like those “spot the difference” games where you look for what changed between two images. This comparison process is called reconciliation. Using smart and efficient algorithms, React figures out exactly what’s different between the two snapshots. Once it knows the differences, React carefully updates only those specific parts of the real webpage (the DOM) that need to change—nothing more. In this case, it simply updates the button text to Value: 1. This snapshot → compare → update cycle is the core flow that React follows to keep the UI fast and in sync with the data.Hence the name of the library-coz it reacts to changes.

#### Mount is the very first time a component appears on the screen. Since React has nothing to compare it with yet, it simply runs the component, creates all the required DOM elements from scratch, and places them on the page.Later, a trigger happens—usually a state update like calling setCount. This does not directly change the screen; it only tells React that some data has changed. Because of this change, React moves to the render phase, where it runs the component function again and creates a fresh description (snapshot) of what the UI should look like now. React then compares this new snapshot with the previous one to find what has changed. Finally, in the commit phase, React applies only those necessary changes to the real DOM—such as updating text, adding new elements, or removing old ones. After committing these updates, React becomes idle again and waits for the next state change to repeat the cycle.React pehle dimaag me sochta hai (render), phir compare karta hai (reconciliation), phir sirf zaroori changes DOM me karta hai (commit), aur tab browser screen repaint karta hai.

#### Trigger → Render (new snapshot) → Reconcile (compare) → Commit (update DOM) → Idle
#### React state updates are asynchronous because when we call a state setter, React does not update the state immediately. Instead, React notes down the change, schedules an update, and then creates a new snapshot of the UI. It compares this new snapshot with the previous one, figures out what has changed, and only updates those parts of the DOM. After that, the browser repaints the screen. Because this whole process happens later, if we log the state immediately after calling the setter, we often see the previous state, not the updated one.
#### Re-rendering in React does not mean that the browser immediately redraws the screen. A re-render means that React calls your component function again and creates a new “snapshot” of the UI using the latest state and props. This whole process happens inside React and is an abstract, internal step. The user does not see anything changing at this stage. After React creates this new snapshot, it performs reconciliation, where it compares the new snapshot with the previous one to figure out what has actually changed. Only after this comparison does React update the real DOM. Finally, the browser repaints the screen based on those DOM updates, and that is the part the user actually sees.

#### When multiple state updates happen inside the same event (like clicking a “Log Out” button), React does not update the UI immediately for each one. Instead, it notes down all the changes, batches them together, and performs one single re-render after the event handler finishes. This is important for both performance and correctness. If state updates were synchronous, React would re-render after every setState call, doing unnecessary extra work and potentially showing broken UI—for example, updating user to null before the confirmation message is ready, resulting in empty or inconsistent content. By keeping state updates asynchronous and batched, React ensures the UI updates once, efficiently, and in a consistent final state, even though it can be confusing at first when logging state values immediately after setting them.
#### A re-render creates and compares UI snapshots inside React, but the browser only repaints when React actually changes the real DOM.Not all re-renders require re-paints! If nothing has changed between snapshots, React won't edit any DOM nodes, and nothing will be re-painted.
#### so first step is to create a form component that will render form- inputs. Next we create states using useState, then inside the state we use object to give values to out multiple inputs. otherwise we would have to make a lot of states in case of multiple inputs. Then we bind out form input by using value attribute and in this value attribute we put state for that perticular input from out state object. Then on the inputs we use name attribute to give them the same name as our states. Till here half binding is done. Now on chnage of input user should be able to type and we should be able to see thta. so we do that by writing onChnage on the input. In select type of input always remeber we put onChnage , value and name on the select . Now onChnage will do these things--> first it will be getting an event object from the browser the moment anyone tries to type in input. next we will target the input using e.target.value and e.target.name. This will give us the value and the input with which the value is attached. Next onChnage of input we need to change the value. so setState function will be called and we will pass updated object of state in it using spread operator in which we will get old objecta dn we will pass whatever new has chnaged. This was we do not muttate the state object directly

####  React 19 introduced Actions as a new way to handle form submissions. In the classic method, we use controlled inputs, where each form field is connected to React state using useState and updated with onChange handlers. This allows React to know the value of each input in real time, making it easy to show live previews, validations, or instant feedback while the user is typing. When the form is submitted, an onSubmit function handles sending the collected state data to the server and managing loading or error states. Actions are a new way to handle form submission in React 19 without using useState for every input.With Actions:React itself collects all input values when the form is submitted , You work with the data only at submit time Instead of tracking input values while the user is typing, React waits until the form is submitted and then automatically collects all the input data for us. In the code, useActionState gives us three things: the current result or error, a function called submitAction that runs when the form is submitted, and a boolean isPending that tells us whether the submission is still in progress. Instead of using onSubmit, we pass submitAction to the form using action={submitAction}, which means “run this action when the form is submitted.” The input fields are uncontrolled, meaning they don’t use value or onChange; they only need a name attribute so React can read their values from formData at submit time. This makes forms less verbose and easier to write, especially large ones, but because the data is only available on submit, Actions are not suitable for cases where we need real-time access to input values, such as live search or instant previews.

#### Forms reload the page by default because of legacy browser behavior. event.preventDefault(). It stops the browser from executing a full page reload.

#### All form controls in React follow the same basic pattern: the current value of the input is locked using either the `value` attribute (for text inputs, textareas, selects, sliders, color pickers, etc.) or the `checked` attribute (for checkboxes and radio buttons), and any change made by the user is handled through the `onChange` event, which updates React state. For text inputs and textareas, controlled components bind state to `value`,
#### while uncontrolled components can use `defaultValue` to set an initial value. It is important to always initialize state with a valid value (usually an empty string for text inputs) to avoid bugs caused by switching from uncontrolled to controlled inputs. 

#### Radio buttons are controlled using a boolean `checked` value and typically share the same `name` attribute so only one option can be selected, while checkboxes also rely on `checked`, storing either a single boolean for one checkbox or an object-like structure for multiple checkboxes. 
#### Select dropdowns work like text inputs, using `value` and `onChange`, and the initial state must exactly match one of the option values to prevent unexpected behavior. 
#### Specialty inputs such as range sliders, date pickers, and color pickers follow the same controlled pattern as text inputs, with the important caveat that input values from the DOM are always strings, even for numeric inputs, so conversion may be required. 
#### Finally, because forms reload the page by default, modern React applications always call `event.preventDefault()` on submit to stop the browser’s default behavior and allow React to handle updates smoothly without a full page refresh.

#### React uses a synthetic event system, which means the events we receive in React are special objects created by React, not the browser’s native JavaScript events. React does this to provide consistent behavior across different browsers, avoiding edge-case differences in how native events work. These synthetic events also improve the developer experience by offering a uniform and predictable API. Earlier versions of React used this system for performance optimizations like event pooling, but this was removed in React 17, so features like event.persist() are no longer needed. If required, the original browser event can still be accessed using event.nativeEvent.Different browsers do not implement events in exactly the same way.The event object, its properties, and even when an event fires can vary slightly between Chrome, Firefox, Safari, Edge, etc.React’s synthetic event system normalizes these differences, so you write one kind of code and it works the same everywhere.

#### Props allow us to customize the behaviour of a given component, so that the exact same component can do different things in different scenarios.Props are the inputs to our components, like arguments passed to a function .React state is used to track data that changes over time By default, state is only made available to the current component. so props: they're the tunnels that allow data to flow through our application.
#### Never mutate React state, even if it appears to work, because React relies on the assumption that state values are treated as immutable.he correct approach is always to create a new copy of the state first, apply changes to that copy, and then pass the new value to the state setter. While some developers worry that creating new arrays or objects on every update might be inefficient, in practice this cost is negligible—modern JavaScript engines can clone arrays extremely quickly, even on low-end hardware, and the time taken is far below what humans can perceive. As a result, immutability is not only safer and more predictable, but also fast enough for real-world front-end applications, making it the correct and recommended way to manage React state.

#### Setting a React list key to Math.random() may remove the warning, but it introduces a serious performance problem because the key changes on every render. Since Math.random() generates a new value each time, React thinks that every item in the list is completely new whenever the component re-renders. As a result, even if only one new item is added, React deletes all existing DOM elements and recreates them from scratch instead of updating only what actually changed. Because DOM operations are relatively expensive, this unnecessary destruction and recreation can significantly hurt performance. The correct idea is not to avoid randomness altogether, but to ensure that the key remains stable across renders. This can be achieved by generating the random ID once—at the moment the item is created, such as inside a click handler—and storing it with the item’s data. In this way, React can reliably identify which items are unchanged and update only the new ones. Besides Math.random(), safer alternatives like crypto.randomUUID() can also be used to generate unique, stable identifiers.Math.random render ke andar galat hai kyunki wo har render pe change hota hai, lekin click handler me sahi hai kyunki wo sirf item create hote waqt ek baar generate hota hai aur phir stable rehta hai.

#### In simple terms, keys help React recognize which item is which in a list. If we use the array index or something like the list length as a key, React can get confused when items are added, removed, or moved, and it may update or delete the wrong elements on the screen. This can cause weird bugs and extra work for the browser. While using indexes might seem fine when the list never changes, it’s easy to be wrong about that. That’s why it’s safer to give each item its own unique and fixed ID so React always knows exactly what has changed.

#### In React, data (state) can only move in one direction, like water flowing downhill — from a parent component to its child components using props. Two sibling components cannot talk to each other directly or share data on their own. So if both siblings need the same information, the only solution is to keep that information in their common parent. The parent then shares the state with both children and can also pass the function that updates the state, so children are allowed to change it.Here’s how it works in real life: when a user types something into a textbox, a change event happens. That change calls a state-update function which actually belongs to the parent component. Because the parent owns the state, updating it causes the parent to re-render, and when the parent re-renders, all its children re-render too. One child (the form) gets the updated value and shows it in the input, while the other child (the results) also receives the same updated value and displays it wherever needed.Now, you might wonder — why not just put all state at the very top of the app? The reason is that doing this in larger apps makes everything slow and messy. Too much state at the top causes unnecessary re-renders and makes the code hard to understand and maintain. That’s why in React, we only “lift state up” when it’s actually shared, not everywhere.

#### parent passes down a function so that the child can update the parent's state
#### Think of a React component like a real object, not just some JSX on the screen. When a component appears on the page for the first time, React “mounts” it, which means two things happen: React turns the JSX into real DOM elements, and at the same time it creates a component instance—a little invisible box that belongs only to that component. This box is where React stores things like state. When we use useState, we’re not storing data in the JSX or in some global place; we’re simply reading from and writing to this component’s own instance box. If the component disappears from the screen because of conditional rendering, React “unmounts” it, which destroys that box and all the state inside it is lost. And because every component on the screen gets its own instance box, React can show multiple copies of the same component, with each copy remembering its own state independently.

#### In React, one important idea is that components are reusable, meaning we should be able to use the same component multiple times on a page without any problems. However, some parts of the web don’t naturally support reusability. For example, HTML id attributes must be unique across the entire page, so if the same component is rendered more than once, it can accidentally create duplicate IDs and cause bugs or accessibility issues. One option is to pass a unique id as a prop, but this relies on the developer remembering to do it correctly every time, which is not very reliable. To solve this problem, React provides the useId hook, which automatically generates a unique ID for each component instance. When a component uses useId, React gives each instance its own stable ID that stays the same across re-renders. Additionally, useId is designed to generate the same ID on both the server and the client, which is especially important for server-side rendering. This makes it a safe and convenient way to handle unique IDs in reusable React components without extra effort or mistakes.n SSR, a React component is rendered once on the server to generate HTML and then rendered again in the browser during hydration. If the IDs generated on the server and client do not match, React can produce warnings or cause UI inconsistencies. useId solves this problem by ensuring that each component instance receives a stable ID that remains consistent across renders and environments, making it safe for reusable components, accessibility attributes, and server-rendered applications.

#### So, we've talked about how hooks are special functions that allow us to “hook” into React internals. useState allows us to hook into a component instance's state, for example, while useId allows us to create and store a unique identifier on the component instance.

#### React has a strict rule that hooks must always be called in the same order on every render. This is because React does not identify hooks by name or ID—instead, it remembers them by the order in which they are called. For example, if a component calls useState first and then another useState, React assumes the first call is always for the first state and the second call is always for the second state. If this order changes between renders, React gets confused and can assign the wrong state to the wrong variable, leading to very strange bugs.This is why hooks are never allowed inside if conditions, loops, or callbacks.

#### Hooks in React must be called inside a React component because hooks are designed to work with React’s internal system that tracks component state and behavior. If we try to call a hook outside a component—like in a normal JavaScript function—React won’t know which component that hook belongs to, so it can’t manage state or effects correctly.Hooks also must be called at the top level of a component, not inside conditions, loops, or nested functions. This is because React relies on the order in which hooks are called to keep track of their values between renders. If hooks were called conditionally, that order could change, and React would get confused about which state or effect belongs to which hook. By always calling hooks at the top level, we ensure that React can reliably match each hook to the correct component instance on every render.

#### React treats state as immutable, meaning we don’t directly change existing objects but instead create new ones when updating state. For example, instead of mutating an object like user.name = 'Ava', React creates a new object using setUser({ name: 'Ava' }), which lives in a different place in memory while the old one still exists briefly. JavaScript stores objects by reference, so even identical-looking objects are considered different if they are created separately. When a component has multiple state variables, React only creates new objects for the state that actually changes and reuses the same references for the rest. This allows React to efficiently detect changes and is the foundation for how hooks like useEffect, useMemo, and useCallback decide when to run.

#### a component instance is a JavaScript object that is the “source of truth” for everything related to a particular instance of a component. It's created when the component is mounted, and it persists until the component is unmounted.

#### A snapshot, by contrast, is not a specific JavaScript object. It's a more abstract/metaphorical concept. It refers to the data available at a moment in time.So, we might say that an instance holds the true value of a piece of state, but every time that state changes, we create a snapshot that captures the current value of that state variable.

#### Local variables don’t persist between renders. When React renders this component a second time, it renders it from scratch—it doesn’t consider any changes to the local variables.Changes to local variables won’t trigger renders. React doesn’t realize it needs to render the component again with the new data.To update a component with new data, two things need to happen:Retain the data between renders.Trigger React to render the component with new data (re-rendering).The useState Hook provides those two things:A state variable to retain the data between renders.A state setter function to update the variable and trigger React to render the component again.

#### On the web, user interfaces are usually built using standard HTML elements like divs, buttons, and forms, where the browser handles how everything looks and behaves. However, there is another powerful way to create visuals on the web using HTML Canvas, which works more like a drawing board. With Canvas, we don’t create UI elements—instead, we use JavaScript to manually draw shapes, pixels, and animations, similar to how Microsoft Paint works. This approach is especially useful for animations, visual effects, particle systems, and games, where we need full control over every frame. Unlike normal DOM-based animations, Canvas requires redrawing the scene again and again using JavaScript, usually with requestAnimationFrame. React is typically used to manage application logic and state, while Canvas handles the visual rendering, making it a great choice for complex and high-performance animations.

#### When we use React, it likes to stay in full control of the UI. We don’t directly touch the real DOM because React manages it for us using its own system, deciding when and how elements should update. If we use something like document.querySelector, we are directly grabbing elements from the browser without React knowing, which means we are going behind React’s back and bypassing its system. This can cause problems because React might re-render or replace those elements later, and our reference can break. To avoid this, React provides refs, which are a safe and approved way to access DOM elements when really needed, such as for working with a canvas. Using useRef, React gives us the DOM element and keeps it updated across renders, allowing us to work with it without breaking React’s flow or causing unexpected bugs.the useRef hook, which creates a persistent container that holds the DOM reference across renders. React fills this container only once when the component mounts, and we can safely access the DOM node later—such as inside a button click handler—without causing extra work. This makes useRef the recommended and performant way to work with DOM elements like canvas in React.

#### When we call React.useRef, we're given an object with a current property.If we pass an object with this shape to the ref attribute, React will mutate this object, setting current equal to the canvas reference.This only runs when the component first renders, leading to improved performance.This is the conventional way to work with DOM node references in React!
### Basically, we use the useRef hook to create a ref “box” that can hold a value. This ref box is an object with a current property, which is initially undefined. We then attach this ref box to a DOM element using the ref attribute. When React renders the component, it automatically puts the actual DOM element into the current property of the ref box. After that, whenever we need to access that DOM element—for example, inside a click handler or an effect—we can simply use domElementRef.current. This lets us safely work with DOM elements without bypassing React’s system.

#### React me useRef tab useful hota hai jab humein kisi real DOM element ko directly control karna hota hai, jaise audio, video, input, ya canvas. useRef sirf ek container deta hai jiska current actual DOM element ko point karta hai, lekin kaam tab hota hai jab humein us DOM element ki native properties aur methods pata hon — jaise <audio> ke play(), pause(), currentTime, volume, ya <input> ke focus(), value, etc. Isliye sirf React hooks samajhna kaafi nahi hota; problems solve karne ke liye HTML/DOM elements ki properties aur methods bhi aani chahiye, jo aksar Google/MDN se dekhni padti hain. React bas bridge hai — actual power DOM APIs me hoti hai.

#### As we build applications, we often need to synchronize with external systems. This can include things like: Making network requests Managing timeouts / intervals Reading/writing from localStorage Listening for global events window resize or keyboard input React calls all of these things “side effects”

#### React’s core responsibility is to keep the DOM in sync with JSX by re-rendering whenever state or props change, but not all logic fits into this render cycle. Tasks like updating the document title, interacting with localStorage, or making network requests exist outside React’s main job and are known as side effects. To manage these safely and predictably, React provides the useEffect hook, which allows us to run side-effect logic after a component has rendered. By passing a dependency array to useEffect, we can control when the effect runs—for example, specifying [count] ensures the effect only re-runs when the count value changes. Importantly, effects always run after the first render, ensuring the component is fully mounted before any side-effect logic executes.

#### Event handlers belong in render scope.Side effects belong in useEffect.

#### useEffect runs after React has finished rendering and updating the DOM. It always runs once after the very first render, ensuring the component is mounted before any side-effect logic executes. After that initial run, useEffect will run again whenever one of the values listed in its dependency array changes; if the dependency array is empty, the effect runs only once on mount, and if no dependency array is provided, the effect runs after every render. In development mode with React Strict Mode enabled, effects may run twice on the initial mount to help detect side-effect bugs, but this behavior does not occur in production.

#### React ka Strict Mode development ke time component ko jaan-boojh kar do baar start aur stop karta hai, taaki yeh check kar sake ki humne apne side effects ko theek se clean up kiya hai ya nahi. Agar useEffect ke andar hum koi cheez start karte hain—jaise timer, event listener, ya subscription—but usse band karne ka cleanup function nahi likhte, toh pehle wala effect background me chalta rehta hai. Jab component dobara mount hota hai, ek naya effect phir se start ho jaata hai, aur isse bugs jaise duplicate logs, multiple API calls, ya memory leaks saamne aa jaate hain. Is tarah Strict Mode humein pehle hi warn kar deta hai ki production me jaakar problem aa sakti hai.

#### in strict mode : mount → interval start Then unmount → cleanup runs → interval cleared  Then mount again → fresh interval start

#### In Strict Mode, React will automatically re-run certain chunks of code, while we're working on our applications. This is done to highlight potential issues.--> In React Strict Mode, useEffect is intentionally run twice during development, but each run is separated by a cleanup. If an effect starts something like a timer, event listener, or subscription and the cleanup function is written correctly, the first effect is properly stopped before the second one runs, so no duplicate behavior appears. However, if the cleanup is missing, the first effect continues running in the background, and when Strict Mode runs the effect again, a second instance is added on top of it. This results in duplicate logs, repeated API calls, or multiple timers, which clearly signals a bug. In short, Strict Mode doesn’t expose bugs because effects run twice—it exposes bugs when cleanup is missing and behavior runs twice.

#### Values stored in localStorage are always saved as strings, regardless of their original data type, so booleans like true or false are stored as "true" and "false". Because of this, when retrieving a value from localStorage, we must convert it back to its original type before using it in our application. A common and reliable way to do this is by using JSON.parse(), which correctly converts stored strings like "true" or "false" back into boolean values. Similarly, when saving values to localStorage, we should use JSON.stringify() to ensure the data is stored in a valid and consistent string format, preventing errors and making the data safe to read later.

#### In React, we can use a function to initialize a state variable by passing a function to useState instead of a direct value. This is called lazy initialization, and it allows the initialization logic to run only once, when the component first renders, rather than on every re-render. This is especially useful when the initial state depends on an expensive operation or external data, such as reading a value from localStorage, because it improves performance and avoids unnecessary repeated work.

#### React shows an ESLint warning because the useEffect hook uses the count state variable but does not include it in the dependency array. This rule exists to prevent effects from becoming out of sync with the rest of the component. Each time setCount is called, React re-renders the component and creates a new “snapshot” of state, meaning a new version of the count variable exists for that render. When count is missing from the dependency array, the effect becomes frozen in time and continues to reference the initial version of count (which was 0), even though the UI and other parts of the component are using the updated value. This leads to confusing behavior where multiple versions of the same state appear to exist at once. By adding count to the dependency array, we ensure the effect re-runs whenever count changes, keeping the effect synchronized with the component’s state and preventing subtle bugs.

#### To build an auto-focusing text input in React, we first need a reference to the actual input DOM element, which we can get using the useRef hook. While input elements provide a .focus() method, we cannot call it directly during render because the ref is still empty at that point—the DOM node doesn’t exist until after the first render completes. Attempting to focus the input during render results in an error since inputRef.current is still undefined. The correct solution is to use the useEffect hook, which runs after React has finished rendering and attaching refs. By placing the focus logic inside useEffect and providing an empty dependency array, we ensure that the effect runs only once, immediately after the component mounts, allowing the input to receive focus safely and reliably.

#### HTML form inputs have an autofocus property that can be used to automatically focus the element on page load: <input autofocus type="text" /> Given that there's a built-in way to auto-focus an input, why are we going through all the trouble with useRef and useEffect?? Unfortunately, it isn't safe to use the autofocus attribute in React. The autofocus attribute only works reliably if the element is present when the page first loads. It won't work if the element is dynamically injected into the page afterwards. And in React, pretty much every element is dynamically injected! The only exception is if you use server-side rendering, and even then, only for the very first page the user visits on your site. And so, the solution shown above, capturing an input with a ref and triggering .focus() in an effect, is the best way to solve this problem in React.

#### When we use things like window.addEventListener, we are signing up for something that keeps running in the background, such as listening to mouse movements. If we put this code inside useEffect without a dependency array, React will run it after every render, which means we accidentally add the same event listener again and again. Since mouse movement itself causes re-renders, this can quickly lead to many duplicate listeners running at the same time. To prevent this, we pass an empty dependency array to useEffect, which tells React to run the effect only once, when the component first appears on the screen. This way, we set up the listener a single time instead of repeatedly, avoiding bugs and performance problems.

#### When we use useEffect to start long-running processes like event listeners, timers, or subscriptions, those processes do not automatically stop when a component unmounts. In the mouse-tracking example, the MouseTracker component adds a global mousemove event listener when it mounts, but when the component is conditionally removed from the UI, the listener keeps running in the background. This causes two serious problems: each time the component is re-mounted, a new event listener is added without removing the old one, and because the listener still references the component’s state updater, the JavaScript garbage collector cannot clean up the old component instance, leading to a memory leak. React cannot remove these listeners automatically because it cannot see what happens inside the effect, and the browser’s event system also has no awareness of React components. To solve this, useEffect allows us to return a cleanup function, which React calls just before the component unmounts. By unsubscribing from the event listener in this cleanup function, we properly stop the long-running process, keep React and the DOM in sync, and prevent memory leaks.

#### React does not run the cleanup function immediately because the effect is meant to start a process and keep it running while the component is active. If React were to execute the cleanup as soon as the effect returns it, the effect would be stopped instantly and long-running processes like event listeners or timers would never actually work. Instead, React stores the cleanup function and runs it later at the correct time—either right before the component unmounts or before the effect runs again due to a dependency change. This design keeps React’s rendering predictable and ensures side effects start and stop at safe, well-defined moments.

#### In useEffect, React asks us to return a function because of JavaScript closures. A closure means that a function can access variables from the scope in which it was created, even after that outer function has finished running. By returning the cleanup function from inside the effect function, the cleanup automatically gets access to everything created inside the effect, such as variables or event handlers. If React had designed the API with two separate functions, the cleanup function would not be able to access those values due to JavaScript scoping rules. This is why useEffect uses the “function that returns a function” pattern—it ensures the cleanup function can safely reference and clean up resources created by the effect, and it’s a practical design choice, not just a stylistic one.

#### When an effect has dependencies, React treats it as something that can start, stop, and restart based on those dependency values. In your example, isEnabled controls whether the mouse-tracking effect should be active. Because hooks cannot be called conditionally, we always call useEffect, but we put the condition inside the effect instead. When isEnabled is added to the dependency array, React knows that this effect depends on its value.

#### Here’s what actually happens: when the component first mounts, React runs the effect and sets up the event listener because isEnabled is true. React also stores the cleanup function returned by the effect. As the mouse moves, state updates happen, but the effect does not re-run because mousePosition is not a dependency. When the user clicks the button and isEnabled changes, React schedules a re-render. Before running the effect again, React always runs the previous cleanup first, removing the event listener. Then React runs the effect again with the new value of isEnabled. If isEnabled is now false, the effect does nothing, so the listener stays removed. This cycle repeats every time isEnabled changes.The key idea is that effects never stack on top of each other. React guarantees a clean slate by running the cleanup from the previous render before applying the next effect. This is why dependency-based effects are predictable, safe, and memory-leak–free—and why the cleanup function is such an important part of the effect lifecycle.

#### The callback escape hatch is used when an effect runs for a long time (like an event listener) and we need access to the latest state value without re-running the effect on every state change. Instead of reading state directly (which can become stale due to closures), we pass a function to the state setter, such as setIsPlaying(currentIsPlaying => !currentIsPlaying). React calls this function with the most recent state value, taken directly from the component instance, not from the old render snapshot. This allows us to safely update state while keeping the effect’s dependency array empty, avoiding unnecessary re-subscriptions and preventing stale state bugs.

#### The state-setter callback is used when we need the latest state value and want to avoid stale data issues. Instead of passing a value, we pass a function to the state setter, and React provides the current state from the component instance. This is especially useful in effects, event listeners, or asynchronous code where closures can capture old values. I usually use it only when needed, not by default, to keep my understanding of React’s render cycle clear.

#### React Strict Mode is a development-only tool that helps surface subtle bugs that are otherwise very hard to detect, such as memory leaks caused by missing cleanup in effects. When enabled, React intentionally runs certain things twice—including effects and renders—to verify that our code is safe to mount, unmount, and re-run. For example, if an effect adds an event listener but forgets to clean it up, Strict Mode will expose the bug immediately by running the effect, cleaning it up, and running it again. This can cause visible issues like duplicated event listeners, making the problem obvious during development. Strict Mode does not affect production performance; it is completely disabled in production builds. Its purpose is not to create bugs, but to reveal existing ones early, encouraging correct cleanup and more robust React code.

#### Although Strict Mode and unmount/remount seem similar because both run effect → cleanup → effect, they are actually very different. In Strict Mode, React does not unmount the component—it keeps the same component instance and intentionally runs the effect twice to check whether the effect and cleanup are written safely. Because the same instance is reused, things like event listeners or state references can conflict if cleanup is missing, which immediately exposes bugs. In contrast, when a component is manually unmounted and then remounted, React creates a brand-new component instance with fresh state and refs. Any old event listeners still exist, but they reference an inactive component and effectively do nothing, so the app appears to work even though a memory leak exists. This is why Strict Mode is more effective: it doesn’t hide bugs by resetting state—it forces effects to be resilient within a single component instance, surfacing problems early during development.
#### Custom hook ka matlab hai ki jo bhi logic tum bar-bar use kar rahi ho—jaise useState, useEffect, timers, event listeners—use ek nayi hook function me daal do. Agar us logic me koi state (useState) use ho rahi hai, to us state ko return kar do, taaki component us value ko use kar sake. Component sirf hook ko call karta hai, aur React baaki kaam automatically handle karta hai.
#### Custom hooks are special because they work with React’s lifecycle—they can store state, start things like timers, and clean them up automatically when the component is removed. That’s why they must start with the word “use”, so React knows this function is part of its system and can manage it safely.custom hooks need to start with the word “use”

#### Hooks have to be called within the scope of a React application. We can't call them outside of our React components.The one exception to this rule is custom hooks. We're allowed to use React hooks like useState and useEffect in a function if that function is a custom hook. We declare that a function is a custom hook by starting it with the word “use”, and making sure it follows the Rules of Hooks (eg. we can't call useTime conditionally, within our component).

#### Data-fetching is a huge part of most React applications. We often have a bunch of data that lives in a database somewhere, and we need to retrieve or update it from our React application. One of the most straightforward ways to make a network request is to use Fetch.Fetch is a built-in part of the web platform, a modern replacement for the clunky XMLHttpRequest. It allows us to make requests over the network.

#### fetch() sends a request to the given URL and returns a Promise.This promise resolves to a Response object once the network call finishes.First .then():response => response.json()This extracts the JSON body from the response (also returns another Promise).Second .then():data => console.log(data)This finally runs when the JSON data is ready, logging the actual result 🎉

#### Asynchronous programming is a technique that enables your program to start a potentially long-running task and still be able to be responsive to other events while that task runs, rather than having to wait until that task has finished. Once that task has finished, your program is presented with the result.

#### a contact form implementation. It includes two controlled inputs for email and message,To submit formThe strategy is to pass a function to the onSubmit attribute on the form, and it will stop the default behavior with event.preventDefault(). We'll use fetch to manage the submission ourselves.To submit the request, we'll call fetch and use the supplied endpoint. Because fetch is promise-based, we'll make it an async function, so that we can await the responseWe want to supply two options:Changing the method to POST, since that's what the endpoint expects.Supplying the data, the email and messageWe need to stringify the data with JSON.stringify(), because it's impossible to send objects over the network. If we don't do this, the browser will try to stringify it for us, and it'll send the string "[object Object]".We'll derive the JSON from the response with await response.json(). This is needed because not all responses include the full body right away (eg. if it's a streaming response).We see that the response was successful, and it reflects the data we submitted for verification.This is the fundamental strategy for doing event-based network requests.Now We need to update the UI so that the user knows what's happening at all times!When submitting network requests, we want to update the UI to indicate 3 different statuses:LoadingSuccessError

#### In simple terms, this approach is about tracking what’s happening with the form so the user always knows what’s going on. We create a status state with four values: idle, loading, success, and error. When the user submits the form, we immediately set the status to loading, which tells the UI that the request is in progress. While loading, we disable all inputs and buttons so the user can’t submit the form multiple times, and we also change the button text to something like “Submitting…” to give clear feedback. After the request completes, we check the response JSON instead of relying only on status codes—if json.ok is true, we set the status to success, otherwise to error. On success, we can either show a confirmation message or reset the form for another submission. On error, we display a simple error message below the form. Overall, this pattern improves user experience by making the form feel responsive, clear, and safe, while still relying on built-in HTML validation for most input errors.

#### fetching data when a component first loads (like showing today’s weather as soon as the page opens) is much harder than fetching data after a button click. To do this, we usually use useEffect, but that brings extra complications, such as handling async code properly and avoiding bugs. On top of that, a real app needs more than just fetching once—we also need to remember the data (cache it) so multiple components can reuse it, and refresh it occasionally so it doesn’t become outdated. Handling all of this manually can get very messy and time-consuming. That’s why most React apps don’t do this from scratch; instead, they use tools like React Query or SWR, which automatically handle fetching, caching, revalidation, and loading states. These tools save a lot of effort and help build reliable, production-ready apps without reinventing the wheel.

#### In simple terms, SWR is a custom React hook that helps us fetch data the smart way without writing a lot of complicated logic ourselves. When we use useSWR(ENDPOINT, fetcher), we are still writing the actual fetch call in the fetcher function, but SWR decides when to run that fetch and what to do with the result. The data returned by the fetcher automatically becomes available as data inside our component, which we can directly use in the UI. The big advantage of SWR is its “stale while revalidate” behavior: it fetches data immediately when the component mounts, shows it to the user, and then quietly re-fetches the data at smart moments (like when the user switches tabs and comes back) to keep it fresh. While the new request is happening, the old data is still shown, so the UI never feels empty or jumpy. Along with this, SWR also handles caching and reuse of data across components, saving us from reinventing complex, error-prone data-fetching logic.

#### In simple terms, SWR helps us handle loading and error states automatically while fetching data. When we use useSWR, it gives us an isLoading value that starts as true and turns false once the request finishes, so we can easily show a “Loading…” message while data is being fetched. For errors, SWR doesn’t automatically treat a failed HTTP response as an error—we need to throw the error ourselves inside the fetcher function. If we throw something (like the JSON returned by the server), SWR catches it and sets the error value for us. This lets us clearly control the UI: show a loading message while fetching, show an error message if something goes wrong, and show the actual data only when everything succeeds. Overall, SWR simplifies data fetching by neatly handling loading, success, and error states without a lot of manual state management.

#### SWR is primarily useful when fetching data on mount.

#### In the book search feature, when the user submits the form, the default browser behavior is prevented and a fetch request is triggered using the GET method. The search term entered by the user is appended to the API endpoint as a query parameter (?searchTerm=value). As soon as the fetch starts, the app sets the status to loading and shows a “Searching…” message. Once the response is received, the JSON body is parsed using response.json(). If the response indicates success, the results array from the JSON is stored in state and rendered using the <SearchResult> component. If the request succeeds but returns an empty array, the status is set to empty and a “No results” message is shown. If the fetch fails or the API returns an error, the status is set to error and an error message is displayed. Before any fetch occurs, the app remains in the idle state and shows a welcome message, with the UI fully controlled by the request lifecycle.

#### To use SWR, we call the useSWR hook with two arguments: a unique key (usually the API endpoint) and a fetcher function. The hook returns an object containing values like data, error, and isLoading, which we destructure inside the component. useSWR automatically decides when to run the request, caches the response, and updates these values as the request progresses, allowing the UI to react easily to loading, success, and error states.The fetcher function contains the actual fetch logic and is responsible for making the network request and returning the parsed data. useSWR calls this fetcher internally and returns an object with values like data, error, and isLoading, which we destructure inside the component. SWR then handles caching, revalidation, and request timing automatically, allowing the UI to respond cleanly to loading, success, and error states.

#### simulatedError=true is a special query parameter provided by the backend API to help developers test error handling. When this parameter is added to the request URL, the server intentionally returns an error response instead of a successful one. This allows us to verify that our application correctly shows error states, such as displaying a “Something went wrong” message, without waiting for a real failure to occur. It is mainly used during development and learning to test how the UI behaves when a request fails, and it is not meant to be used in production.

#### In React, the function we pass to useEffect cannot be async, even though it may look logical to use async/await directly. This is because async functions always return a Promise, and React expects the effect to either return nothing or return a cleanup function, not a Promise. If React received a Promise instead of a cleanup function, it wouldn’t know how or when to clean things up, especially if the component unmounts while an async task is still running. To solve this, we define an async function inside the effect and call it immediately. This way, React gets the cleanup function synchronously, while the async work runs safely inside. Data-fetching libraries like SWR handle this internally, which is why we don’t face this issue when using them.

#### Memoization in React is a performance optimization technique used to avoid unnecessary re-renders. In large applications, even small state changes can cause many unrelated components to re-render, which can hurt performance. React provides tools like React.memo, useCallback, and useMemo to remember previously computed values or functions and reuse them when inputs haven’t changed, ensuring that components only re-render when they actually need to.

#### Re-renders only affect the component that owns the state + its descendants (if any)This is how React ensures the UI stays in sync
#### When a component re-renders, it tries to re-render all descendants, regardless of whether they're being passed a particular state variable through props or not. it's hard for React to know, with 100% certainty, whether <Decoration> depends, directly or indirectly, on the count state variable.

#### Rendering in React means re-running component functions to create a new snapshot of what the UI should look like, while painting means the browser actually updating pixels on the screen. A re-render does not automatically change the DOM—React will only update the DOM if it finds differences during reconciliation. While unnecessary re-renders can add some overhead in large apps, most of the time they’re very cheap, and React is highly optimized for this. Because of this, we usually don’t need to worry about micro-optimizing renders unless there’s a real performance problem.

#### a component will automatically re-render when its parent re-renders, regardless of whether or not its props have changed.In larger applications, this can lead to performance problems. A single state change might re-render dozens or even hundreds of components, even if only a small fraction of them actually need to re-render.Fortunately, React provides an escape hatch we can use: the React.memo utility.

#### React.memo is a utility that lets us tell React: “Hey, this component is pure! It doesn't need to re-render unless its props or state changes. It will always return the exact same UI when given the same props + state”.It takes a component as an argument (Decoration) and augments it, giving it a new super-power: it can selectively ignore re-renders that don't affect it.When the parent component re-renders, React will try to re-render the child PureDecoration, but PureDecoration steps in and says “None of my props have changed, and so I won't be re-rendering this time.”This uses a technique known as memoization.A pure component is one that always produces the same UI when given the same props.The idea is that React will remember the previous snapshot. If none of the props have changed, React will re-use that stale snapshot rather than going through the trouble of generating a brand new one.

#### The only way to re-render anything in React is to update a state variable by calling a state-setter function (eg. setCount).When a component re-renders, it automatically re-renders all of its descendants, even if none of their props have changed.We can wrap our component with React.memo to optimize it, so that it only re-renders if at least 1 of its props have changed since the last render.

#### useMemo ka simple kaam hai heavy calculation ko baar-baar hone se bachana. Normally, jab bhi React component re-render hota hai, poora code fir se chalta hai — chahe data badla ho ya nahi. Tumhare example me, prime numbers nikalna ek mehenga (slow) kaam hai. Problem ye thi ki digital clock har second update hoti hai, aur uski wajah se prime numbers wali calculation bhi har second fir se chal rahi thi, jabki number same hi tha.useMemo yahan bolta hai: “Agar number same hai, toh purani calculation yaad rakho, dobara mat nikaalo.” React sirf tab primes dobara calculate karega jab selectedNum change hoga. Baaki renders me React saved value use karega. Isse app smooth rehti hai aur unnecessary work nahi hota.

#### The fundamental idea with useMemo is that it allows us to “remember” a computed value between renders.

#### During mount, when this component is rendered for the very first time, React will invoke this function to run all of this logic, calculating all of the primes. Whatever we return from this function is assigned to the allPrimes variable.For every subsequent render, however, React has a choice to make. Should it:Invoke the function again, to re-calculate the value, orRe-use the data it already has, from the last time it did this work.To answer this question, React looks at the supplied list of dependencies. Have any of them changed since the previous render? If so, React will rerun the supplied function, to calculate a new value. Otherwise, it'll skip all that work and reuse the previously-calculated value.useMemo is essentially like a lil’ cache, and the dependencies are the cache invalidation strategy.In this case, we're essentially saying “recalculate the list of primes only when selectedNum changes”. When the component re-renders for other reasons (eg. the time state variable changing), useMemo ignores the function and passes along the cached value.

#### the structure for useMemo is quite a lot like the structure for useEffect! They both take a callback function and a dependency array.The main difference is that useMemo is used to calculate a value during render. Effects, meanwhile, invoke the callback function after the render, to synchronize React state with some sort of external system.You might also have noticed: the useMemo hook has a similar name to the React.memo helper we saw in the previous lesson.This is no coincidence! In fact, they both do similar things:React.memo memoizes the result of rendering a component, only re-running when the props change.React.useMemo memoizes the result of a computation, only re-running when the dependencies change.

#### By preserving the same reference across multiple renders, we allow pure components to function the way we want them to, ignoring renders that don't affect the UI.Concept – useMemo for preserved references (Revision Note)React me jab parent component re-render hota hai, uske andar likha hua code fir se run hota hai. Agar hum render ke andar array ya object directly bana dete hain, toh har render me uska naya reference create ho jata hai, chahe data same hi kyun na ho. React.memo sirf reference compare karta hai, isliye naya reference milte hi child component re-render ho jata hai.useMemo ka use yahan performance ke liye nahi, balki reference ko preserve karne ke liye hota hai. useMemo React ko bolta hai: “jab tak dependencies change na ho, tab tak wahi purana array/object reuse karo.” Isse pure components unnecessary re-renders ignore kar paate hain aur sirf tab re-render hote hain jab actual data change hota hai.

####  useCallback It solves the same “preserved references” problem as useMemo, but for functions instead of arrays / objects.Similar to arrays and objects, functions are compared by reference, not by value:This means that if we define a function within our components, it'll be re-generated on every single render, producing an identical-but-unique function each time.

#### React components should be thought of as closed systems, just like external services such as Twitter. Just as we can’t access Twitter’s database directly and must interact through its API, we can’t access a component’s internal logic or markup directly—we interact with it only through props, which act as the component’s interface. When we build components, we are the producers deciding what props exist, how they behave, and what is hidden. Other developers (or future us) become consumers of that component. In large, long-term projects, this matters a lot, because components like buttons or inputs are used repeatedly for years. If the props are intuitive, consistent, and well-designed, the app feels easy to maintain; if not, it becomes frustrating. That’s why the consumer experience of a component is more important than how easy it was to build, and we should design props thoughtfully, just like a good API.